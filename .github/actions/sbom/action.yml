name: "kfm/sbom üß¨"
description: "Generate SBOM artifacts (SPDX/CycloneDX) for the repo and/or container images ‚Äî aligned with KFM promotion + provenance gates."
author: "Kansas Frontier Matrix (KFM)"

inputs:
  mode:
    description: "SBOM target(s): repo | image | both"
    required: false
    default: "repo"

  repo_path:
    description: "üìÅ Path to scan when mode includes 'repo' (e.g., '.' or 'src/server')."
    required: false
    default: "."

  image_ref:
    description: "üê≥ Image reference when mode includes 'image' (prefer digest pin: ghcr.io/org/img@sha256:...)."
    required: false
    default: ""

  formats:
    description: "Comma-separated output formats: spdx-json, cyclonedx-json (aliases: spdx, cdx, cyclonedx)."
    required: false
    default: "spdx-json"

  tool:
    description: "SBOM generator backend (currently supported: syft)."
    required: false
    default: "syft"

  syft_version:
    description: "Syft release tag to install (pin for determinism). Example: v1.40.0"
    required: false
    default: "v1.40.0"

  output_dir:
    description: "üì¶ Directory for SBOM outputs + reports (recommended: .artifacts/sbom)."
    required: false
    default: ".artifacts/sbom"

  attestations_dir:
    description: "üîè Directory for canonical attestation materials (recommended: .artifacts/attestations)."
    required: false
    default: ".artifacts/attestations"

  copy_to_attestations:
    description: "Copy the PRIMARY SBOM into attestations_dir with KFM canonical names (materials.sbom.*.json)."
    required: false
    default: "true"

  require_image_digest:
    description: "Require digest pinning for remote images: auto | true | false"
    required: false
    default: "auto"

  fail_on_warn:
    description: "Fail on warnings that would weaken promotion safety (e.g., remote image without digest)."
    required: false
    default: "true"

  fail_on_error:
    description: "Fail if SBOM generation fails."
    required: false
    default: "true"

  upload_artifact:
    description: "Upload SBOM outputs as a workflow artifact (true|false)."
    required: false
    default: "true"

  artifact_name:
    description: "Artifact name when uploading. Use 'auto' to include the commit SHA."
    required: false
    default: "auto"

outputs:
  sbom_spdx_path:
    description: "Path to canonical SPDX SBOM (attestations copy when enabled)."
    value: ${{ steps.out.outputs.sbom_spdx_path }}

  sbom_cdx_path:
    description: "Path to canonical CycloneDX SBOM (attestations copy when enabled)."
    value: ${{ steps.out.outputs.sbom_cdx_path }}

  sbom_summary_path:
    description: "Path to SBOM summary markdown."
    value: ${{ steps.out.outputs.sbom_summary_path }}

  sbom_target:
    description: "mode used: repo | image | both"
    value: ${{ steps.out.outputs.sbom_target }}

  primary_target:
    description: "Primary SBOM target used for canonical copies: repo | image"
    value: ${{ steps.out.outputs.primary_target }}

  image_digest:
    description: "Resolved image digest (sha256:...) when mode includes image, if detectable."
    value: ${{ steps.out.outputs.image_digest }}

runs:
  using: "composite"
  steps:
    - name: üßæ Prepare inputs (fail-fast)
      id: prep
      shell: bash
      run: |
        set -euo pipefail

        MODE="${{ inputs.mode }}"
        case "$MODE" in
          repo|image|both) ;;
          *)
            echo "::error::Invalid mode: '$MODE' (expected: repo|image|both)"
            exit 1
            ;;
        esac

        FORMATS_RAW="${{ inputs.formats }}"
        FORMATS="$(echo "$FORMATS_RAW" | tr '[:upper:]' '[:lower:]' | tr -d ' ')"

        WANT_SPDX="false"
        WANT_CDX="false"

        IFS=',' read -ra _fmts <<< "$FORMATS"
        for f in "${_fmts[@]}"; do
          case "$f" in
            "" ) ;;
            spdx|spdx-json) WANT_SPDX="true" ;;
            cdx|cyclonedx|cdx-json|cyclonedx-json) WANT_CDX="true" ;;
            *)
              echo "::error::Unsupported format '$f'. Use: spdx-json and/or cyclonedx-json"
              exit 1
              ;;
          esac
        done

        if [ "$WANT_SPDX" = "false" ] && [ "$WANT_CDX" = "false" ]; then
          echo "::error::No valid formats selected (formats='${{ inputs.formats }}')"
          exit 1
        fi

        REPO_PATH="${{ inputs.repo_path }}"
        OUT_DIR="${{ inputs.output_dir }}"
        ATT_DIR="${{ inputs.attestations_dir }}"

        mkdir -p "$OUT_DIR" "$ATT_DIR"

        IMAGE_REF="${{ inputs.image_ref }}"
        if [ "$MODE" = "image" ] || [ "$MODE" = "both" ]; then
          if [ -z "$IMAGE_REF" ]; then
            echo "::error::image_ref is required when mode=image|both"
            exit 1
          fi
        fi

        ART_NAME="${{ inputs.artifact_name }}"
        if [ "$ART_NAME" = "auto" ]; then
          ART_NAME="sbom-${GITHUB_SHA}"
        fi

        # Standardized output paths (repo + image get distinct files)
        echo "want_spdx=$WANT_SPDX" >> "$GITHUB_OUTPUT"
        echo "want_cdx=$WANT_CDX" >> "$GITHUB_OUTPUT"
        echo "mode=$MODE" >> "$GITHUB_OUTPUT"
        echo "repo_path=$REPO_PATH" >> "$GITHUB_OUTPUT"
        echo "image_ref=$IMAGE_REF" >> "$GITHUB_OUTPUT"
        echo "output_dir=$OUT_DIR" >> "$GITHUB_OUTPUT"
        echo "attestations_dir=$ATT_DIR" >> "$GITHUB_OUTPUT"
        echo "artifact_name=$ART_NAME" >> "$GITHUB_OUTPUT"

        echo "repo_spdx_path=$OUT_DIR/sbom.repo.spdx.json" >> "$GITHUB_OUTPUT"
        echo "repo_cdx_path=$OUT_DIR/sbom.repo.cdx.json" >> "$GITHUB_OUTPUT"
        echo "image_spdx_path=$OUT_DIR/sbom.image.spdx.json" >> "$GITHUB_OUTPUT"
        echo "image_cdx_path=$OUT_DIR/sbom.image.cdx.json" >> "$GITHUB_OUTPUT"
        echo "summary_path=$OUT_DIR/sbom.summary.md" >> "$GITHUB_OUTPUT"
        echo "meta_path=$OUT_DIR/sbom.meta.json" >> "$GITHUB_OUTPUT"

        # Canonical ‚Äúmaterials.*‚Äù filenames for attestation bundles
        echo "attest_spdx_path=$ATT_DIR/materials.sbom.spdx.json" >> "$GITHUB_OUTPUT"
        echo "attest_cdx_path=$ATT_DIR/materials.sbom.cdx.json" >> "$GITHUB_OUTPUT"

    - name: üß¨ Install Syft (pinned + checksum-verified)
      if: ${{ inputs.tool == 'syft' }}
      shell: bash
      run: |
        set -euo pipefail

        SYFT_VERSION="${{ inputs.syft_version }}"
        if [[ "$SYFT_VERSION" != v* ]]; then
          SYFT_VERSION="v${SYFT_VERSION}"
        fi
        VER_NO_V="${SYFT_VERSION#v}"

        OS="$(uname -s | tr '[:upper:]' '[:lower:]')"
        if [ "$OS" != "linux" ]; then
          echo "::error::Unsupported runner OS '$OS' (this action currently supports linux runners only)"
          exit 1
        fi

        ARCH="$(uname -m)"
        case "$ARCH" in
          x86_64|amd64) ARCH="amd64" ;;
          aarch64|arm64) ARCH="arm64" ;;
          *)
            echo "::error::Unsupported runner arch '$ARCH'"
            exit 1
            ;;
        esac

        ASSET_TAR="syft_${VER_NO_V}_${OS}_${ARCH}.tar.gz"
        BASE_URL="https://github.com/anchore/syft/releases/download/${SYFT_VERSION}"

        TMP="${RUNNER_TEMP}/syft-${VER_NO_V}"
        mkdir -p "$TMP"

        echo "üì• Downloading Syft ${SYFT_VERSION} (${OS}/${ARCH})"
        curl -sSfL "${BASE_URL}/syft_${VER_NO_V}_checksums.txt" -o "$TMP/checksums.txt"
        curl -sSfL "${BASE_URL}/${ASSET_TAR}" -o "$TMP/${ASSET_TAR}"

        EXPECTED="$(grep " ${ASSET_TAR}$" "$TMP/checksums.txt" | awk '{print $1}' || true)"
        if [ -z "$EXPECTED" ]; then
          echo "::error::Could not find checksum for ${ASSET_TAR} in checksums file"
          exit 1
        fi

        ACTUAL="$(sha256sum "$TMP/${ASSET_TAR}" | awk '{print $1}')"
        if [ "$EXPECTED" != "$ACTUAL" ]; then
          echo "::error::Syft checksum mismatch for ${ASSET_TAR}"
          echo "::error::expected=$EXPECTED"
          echo "::error::actual=$ACTUAL"
          exit 1
        fi

        tar -xzf "$TMP/${ASSET_TAR}" -C "$TMP"
        chmod +x "$TMP/syft"
        echo "$TMP" >> "$GITHUB_PATH"

        echo "‚úÖ Syft installed:"
        syft version

    - name: üß¨ Generate SBOM(s)
      id: gen
      shell: bash
      run: |
        set -euo pipefail

        MODE="${{ steps.prep.outputs.mode }}"
        REPO_PATH="${{ steps.prep.outputs.repo_path }}"
        IMAGE_REF="${{ steps.prep.outputs.image_ref }}"
        OUT_DIR="${{ steps.prep.outputs.output_dir }}"
        ATT_DIR="${{ steps.prep.outputs.attestations_dir }}"

        WANT_SPDX="${{ steps.prep.outputs.want_spdx }}"
        WANT_CDX="${{ steps.prep.outputs.want_cdx }}"

        REPO_SPDX="${{ steps.prep.outputs.repo_spdx_path }}"
        REPO_CDX="${{ steps.prep.outputs.repo_cdx_path }}"
        IMAGE_SPDX="${{ steps.prep.outputs.image_spdx_path }}"
        IMAGE_CDX="${{ steps.prep.outputs.image_cdx_path }}"

        SUMMARY="${{ steps.prep.outputs.summary_path }}"
        META="${{ steps.prep.outputs.meta_path }}"

        ATTEST_SPDX="${{ steps.prep.outputs.attest_spdx_path }}"
        ATTEST_CDX="${{ steps.prep.outputs.attest_cdx_path }}"

        COPY_ATTEST="${{ inputs.copy_to_attestations }}"
        FAIL_ON_WARN="${{ inputs.fail_on_warn }}"
        FAIL_ON_ERROR="${{ inputs.fail_on_error }}"
        REQUIRE_DIGEST="${{ inputs.require_image_digest }}"

        if ! command -v syft >/dev/null 2>&1; then
          echo "::error::syft not found on PATH (tool='${{ inputs.tool }}')"
          exit 1
        fi

        # Helper: run syft with multiple -o outputs (only writes enabled formats)
        run_syft() {
          local TARGET="$1"
          local SPDx_OUT="$2"
          local CDX_OUT="$3"

          local args=()
          if [ "$WANT_SPDX" = "true" ]; then
            args+=("-o" "spdx-json=${SPDx_OUT}")
          fi
          if [ "$WANT_CDX" = "true" ]; then
            args+=("-o" "cyclonedx-json=${CDX_OUT}")
          fi

          echo "‚û°Ô∏è  syft '${TARGET}' ${args[*]}"
          syft "${TARGET}" "${args[@]}"
        }

        GENERATED_REPO="false"
        GENERATED_IMAGE="false"
        IMAGE_DIGEST=""

        if [ "$MODE" = "repo" ] || [ "$MODE" = "both" ]; then
          run_syft "dir:${REPO_PATH}" "$REPO_SPDX" "$REPO_CDX"
          GENERATED_REPO="true"
        fi

        if [ "$MODE" = "image" ] || [ "$MODE" = "both" ]; then
          # Prefer digest pinning for remote images in promotion lanes
          if [[ "$IMAGE_REF" == *@sha256:* ]]; then
            IMAGE_DIGEST="${IMAGE_REF#*@}"
          else
            # Try to resolve a digest if docker can see/pull the image
            if command -v docker >/dev/null 2>&1; then
              echo "üîé Attempting to resolve image digest via docker inspect (best-effort)..."
              docker pull "${IMAGE_REF}" >/dev/null 2>&1 || true
              RESOLVED="$(docker image inspect "${IMAGE_REF}" --format='{{index .RepoDigests 0}}' 2>/dev/null || true)"
              if [[ "$RESOLVED" == *@sha256:* ]]; then
                IMAGE_DIGEST="${RESOLVED#*@}"
              fi
            fi

            if [ "$REQUIRE_DIGEST" = "true" ]; then
              echo "::error::image_ref must be digest-pinned (expected @sha256:...)"
              exit 1
            fi

            if [ "$REQUIRE_DIGEST" = "auto" ]; then
              FIRST_SEGMENT="$(echo "$IMAGE_REF" | awk -F/ '{print $1}')"
              if [[ "$FIRST_SEGMENT" == *.* || "$FIRST_SEGMENT" == "ghcr.io" || "$FIRST_SEGMENT" == "docker.io" ]]; then
                if [ "$FAIL_ON_WARN" = "true" ]; then
                  echo "::error::Remote image_ref is not digest-pinned: ${IMAGE_REF}"
                  echo "::error::Use an @sha256 digest for promotion lanes."
                  exit 1
                else
                  echo "::warning::Remote image_ref is not digest-pinned: ${IMAGE_REF}"
                fi
              else
                echo "::notice::image_ref is not digest-pinned (likely local): ${IMAGE_REF}"
              fi
            fi
          fi

          run_syft "${IMAGE_REF}" "$IMAGE_SPDX" "$IMAGE_CDX"
          GENERATED_IMAGE="true"
        fi

        # Primary target: prefer image if generated; else repo
        PRIMARY="repo"
        PRIMARY_SPDX="$REPO_SPDX"
        PRIMARY_CDX="$REPO_CDX"
        if [ "$GENERATED_IMAGE" = "true" ]; then
          PRIMARY="image"
          PRIMARY_SPDX="$IMAGE_SPDX"
          PRIMARY_CDX="$IMAGE_CDX"
        fi

        SBOM_SPDX_CANON=""
        SBOM_CDX_CANON=""

        if [ "$COPY_ATTEST" = "true" ]; then
          mkdir -p "$ATT_DIR"
          if [ "$WANT_SPDX" = "true" ] && [ -f "$PRIMARY_SPDX" ]; then
            cp "$PRIMARY_SPDX" "$ATTEST_SPDX"
            SBOM_SPDX_CANON="$ATTEST_SPDX"
          fi
          if [ "$WANT_CDX" = "true" ] && [ -f "$PRIMARY_CDX" ]; then
            cp "$PRIMARY_CDX" "$ATTEST_CDX"
            SBOM_CDX_CANON="$ATTEST_CDX"
          fi
        else
          if [ "$WANT_SPDX" = "true" ]; then SBOM_SPDX_CANON="$PRIMARY_SPDX"; fi
          if [ "$WANT_CDX" = "true" ]; then SBOM_CDX_CANON="$PRIMARY_CDX"; fi
        fi

        # Generate a short summary for humans (policy gates consume JSON)
        SYFT_VER="$(syft version 2>/dev/null | head -n 1 || true)"

        # Package count (best-effort)
        PKG_COUNT=""
        if [ -n "$SBOM_SPDX_CANON" ] && [ -f "$SBOM_SPDX_CANON" ] && command -v python >/dev/null 2>&1; then
          PKG_COUNT="$(python - <<PY
import json
p = r"${SBOM_SPDX_CANON}"
try:
  with open(p, "r", encoding="utf-8") as f:
    data = json.load(f)
  pkgs = data.get("packages") or []
  print(len(pkgs))
except Exception:
  print("")
PY
)"
        fi

        {
          echo "# üß¨ SBOM Summary"
          echo ""
          echo "- üß© mode: \`${MODE}\`"
          echo "- üéØ primary: \`${PRIMARY}\`"
          echo "- üß∞ tool: \`${{ inputs.tool }}\`"
          echo "- üß∑ syft: \`${SYFT_VER}\`"
          if [ "$GENERATED_IMAGE" = "true" ]; then
            echo "- üê≥ image_ref: \`${IMAGE_REF}\`"
            if [ -n "$IMAGE_DIGEST" ]; then
              echo "- üîí image_digest: \`${IMAGE_DIGEST}\`"
            fi
          fi
          if [ -n "$PKG_COUNT" ]; then
            echo "- üì¶ package_count (SPDX packages): \`${PKG_COUNT}\`"
          fi
          echo ""
          echo "## üìÑ Outputs"
          if [ "$GENERATED_REPO" = "true" ]; then
            [ "$WANT_SPDX" = "true" ] && echo "- üìÅ repo SPDX: \`${REPO_SPDX}\`"
            [ "$WANT_CDX" = "true" ] && echo "- üìÅ repo CDX:  \`${REPO_CDX}\`"
          fi
          if [ "$GENERATED_IMAGE" = "true" ]; then
            [ "$WANT_SPDX" = "true" ] && echo "- üê≥ image SPDX: \`${IMAGE_SPDX}\`"
            [ "$WANT_CDX" = "true" ] && echo "- üê≥ image CDX:  \`${IMAGE_CDX}\`"
          fi
          if [ -n "$SBOM_SPDX_CANON" ]; then
            echo "- üîè canonical SPDX (promotion artifact): \`${SBOM_SPDX_CANON}\`"
          fi
          if [ -n "$SBOM_CDX_CANON" ]; then
            echo "- üîè canonical CDX (promotion artifact):  \`${SBOM_CDX_CANON}\`"
          fi
          echo ""
          echo "## ‚úÖ KFM stance"
          echo "- SBOMs are treated as **supply-chain evidence artifacts**."
          echo "- Promotion should be **fail-closed** if SBOM evidence is missing."
        } > "$SUMMARY"

        # Minimal JSON meta for policy engines / provenance stitching
        export KFM_MODE="$MODE"
        export KFM_PRIMARY="$PRIMARY"
        export KFM_TOOL="${{ inputs.tool }}"
        export KFM_SYFT_VERSION="${{ inputs.syft_version }}"
        export KFM_IMAGE_REF="$IMAGE_REF"
        export KFM_IMAGE_DIGEST="$IMAGE_DIGEST"

        python - <<'PY' > "$META"
import json, os
meta = {
  "repo": os.environ.get("GITHUB_REPOSITORY"),
  "sha": os.environ.get("GITHUB_SHA"),
  "run_id": os.environ.get("GITHUB_RUN_ID"),
  "mode": os.environ.get("KFM_MODE"),
  "primary": os.environ.get("KFM_PRIMARY"),
  "tool": os.environ.get("KFM_TOOL"),
  "syft_version": os.environ.get("KFM_SYFT_VERSION"),
  "image_ref": os.environ.get("KFM_IMAGE_REF"),
  "image_digest": os.environ.get("KFM_IMAGE_DIGEST"),
}
print(json.dumps(meta, indent=2))
PY

        # Expose step outputs for downstream workflows
        echo "sbom_spdx_path=${SBOM_SPDX_CANON}" >> "$GITHUB_OUTPUT"
        echo "sbom_cdx_path=${SBOM_CDX_CANON}" >> "$GITHUB_OUTPUT"
        echo "sbom_summary_path=${SUMMARY}" >> "$GITHUB_OUTPUT"
        echo "primary_target=${PRIMARY}" >> "$GITHUB_OUTPUT"
        echo "image_digest=${IMAGE_DIGEST}" >> "$GITHUB_OUTPUT"

    - name: üì¶ Upload SBOM artifacts
      if: ${{ inputs.upload_artifact == 'true' }}
      uses: actions/upload-artifact@v4
      with:
        name: ${{ steps.prep.outputs.artifact_name }}
        if-no-files-found: error
        path: |
          ${{ steps.prep.outputs.output_dir }}/**
          ${{ steps.prep.outputs.attestations_dir }}/materials.sbom.*.json

    - name: üì§ Set action outputs
      id: out
      shell: bash
      run: |
        set -euo pipefail
        echo "sbom_spdx_path=${{ steps.gen.outputs.sbom_spdx_path }}" >> "$GITHUB_OUTPUT"
        echo "sbom_cdx_path=${{ steps.gen.outputs.sbom_cdx_path }}" >> "$GITHUB_OUTPUT"
        echo "sbom_summary_path=${{ steps.gen.outputs.sbom_summary_path }}" >> "$GITHUB_OUTPUT"
        echo "sbom_target=${{ steps.prep.outputs.mode }}" >> "$GITHUB_OUTPUT"
        echo "primary_target=${{ steps.gen.outputs.primary_target }}" >> "$GITHUB_OUTPUT"
        echo "image_digest=${{ steps.gen.outputs.image_digest }}" >> "$GITHUB_OUTPUT"

