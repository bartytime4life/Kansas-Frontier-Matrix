---
title: "Kansas Frontier Matrix ‚Äî GitHub Workflows"
path: ".github/workflows/README.md"
version: "v1.0.0"
last_updated: "2025-12-19"
status: "draft"
doc_kind: "CI Guide"
license: "CC-BY-4.0"

markdown_protocol_version: "KFM-MDP v11.2.6"
mcp_version: "MCP-DL v6.3"
ontology_protocol_version: "KFM-ONTO v4.1.0"
pipeline_contract_version: "KFM-PPC v11.0.0"
stac_profile: "KFM-STAC v11.0.0"
dcat_profile: "KFM-DCAT v11.0.0"
prov_profile: "KFM-PROV v11.0.0"

governance_ref: "docs/governance/ROOT_GOVERNANCE.md"
ethics_ref: "docs/governance/ETHICS.md"
sovereignty_policy: "docs/governance/SOVEREIGNTY.md"
fair_category: "FAIR+CARE"
care_label: "TBD"
sensitivity: "public"
classification: "open"
jurisdiction: "US-KS"

doc_uuid: "urn:kfm:doc:github:workflows-readme:v1.0.0"
semantic_document_id: "kfm-github-workflows-readme-v1.0.0"
event_source_id: "ledger:kfm:doc:github:workflows-readme:v1.0.0"
commit_sha: "<latest-commit-hash>"

ai_transform_permissions:
  - "summarize"
  - "structure_extract"
  - "translate"
  - "keyword_index"
ai_transform_prohibited:
  - "generate_policy"
  - "infer_sensitive_locations"

doc_integrity_checksum: "sha256:<calculate-and-fill>"
---

# GitHub Workflows

## üìò Overview

### Purpose
This directory contains GitHub Actions workflows used to validate KFM changes. Workflows act as CI gates
for documentation integrity, catalog validity, and policy/behavior checks.

### Scope
| In Scope | Out of Scope |
|---|---|
| Workflows under `.github/workflows/` | Deployment workflows (not confirmed in repo) |
| CI validation and policy gates | Organization policy text (lives in `docs/governance/`) |

### Audience
- Primary: maintainers, reviewers
- Secondary: contributors adding datasets, docs, APIs, UI changes

### Definitions
- Glossary link: `docs/glossary.md` (not confirmed in repo)

### Key artifacts
| Artifact | Path / Identifier | Owner | Notes |
|---|---|---|---|
| AI behavior check workflow | `.github/workflows/ai_behavior_check.yml` | Maintainers | Guards against chat artifacts + enforces governed doc front matter |
| Architecture doc | `ARCHITECTURE.md` | Maintainers | System invariants reference |
| Master guide | `docs/MASTER_GUIDE_v12.md` | Maintainers | Canonical pipeline ordering |

### Definition of done
- [ ] Workflows use least-privilege permissions
- [ ] Workflows avoid secrets unless explicitly required and documented
- [ ] Workflow outputs are deterministic and reproducible
- [ ] Policy gates produce actionable failure messages

## üóÇÔ∏è Directory Layout

### This document
- `path`: `.github/workflows/README.md`

### Expected file tree
~~~text
üìÅ .github/
‚îî‚îÄ‚îÄ üìÅ workflows/
    ‚îú‚îÄ‚îÄ üìÑ README.md
    ‚îî‚îÄ‚îÄ üìÑ ai_behavior_check.yml
~~~

## üß≠ Context

### Background
KFM relies on provenance-linked, governed outputs. CI gates help ensure:
- Documents remain protocol-compliant and free of chat artifacts
- Catalog artifacts validate against schemas
- Contract boundaries (API boundary, provenance-first Focus Mode) are not accidentally violated

### Assumptions
- Contributors may add new Markdown docs frequently (reports, story nodes, design docs)
- Some content may be AI-assisted; committed files must still be repo-clean and reviewable

### Constraints and invariants
- Least-privilege by default: `permissions: contents: read`
- No workflow should ‚Äúsilently‚Äù publish data or modify protected branches (unless explicitly governed)

## üó∫Ô∏è Diagrams

### CI policy gate placement
~~~mermaid
flowchart LR
  A[Pull Request] --> B[CI Workflows]
  B --> C[Docs + Catalog + Contract Checks]
  C --> D[Merge Allowed]
~~~

## üì¶ Data & Metadata

### Inputs
| Input | Format | Where from | Validation |
|---|---|---|---|
| PR diff | Git refs | GitHub event payload | deterministic diff selection |
| Repository files | text/binary | workspace checkout | text/binary heuristics |

### Outputs
| Output | Format | Path | Contract / Schema |
|---|---|---|---|
| CI status checks | GitHub check | PR checks UI | must be actionable |

## üß± Architecture

### Workflow overview

#### `ai_behavior_check.yml`
Purpose:
- Reject ‚Äúchat artifacts‚Äù in committed files (e.g., tool IDs, filecite tokens, `turn...` references)
- Enforce governed Markdown documents to include YAML front matter and correct `path:` field
- Encourage KFM Markdown protocol (prefer `~~~` fences over triple backticks in governed docs)

Notes:
- This workflow is intended as a lightweight policy gate. It is not a substitute for schema validation
  of STAC/DCAT/PROV or API contract testing.

### Adding a new workflow
- Prefer path filters to avoid unnecessary CI load.
- Prefer standard, pinned GitHub actions.
- Document the workflow in this README and link any schemas/tests it enforces.

## üß™ Validation & CI/CD

### Validation steps
- [ ] Workflow YAML lint (optional; not confirmed in repo)
- [ ] Policy gates pass on PRs
- [ ] Workflow permissions reviewed in code review

### Reproduction
~~~bash
# There is no single local runner guaranteed in this repo.
# If you use `act` locally, ensure results match GitHub runners (not confirmed in repo).
~~~

## ‚öñ FAIR+CARE & Governance

### Review triggers
- Any workflow adding secrets, write permissions, or publishing artifacts requires security review.
- Any workflow that could touch restricted/sensitive content requires governance review.

## üï∞Ô∏è Version History

| Version | Date | Summary | Author |
|---|---|---|---|
| v1.0.0 | 2025-12-19 | Initial workflows README + behavior gate documentation | TBD |


~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
FILE: .github/workflows/ai_behavior_check.yml
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
name: AI Behavior Check

on:
  pull_request:
    paths:
      - "docs/**/*.md"
      - "ARCHITECTURE.md"
      - ".github/workflows/**/*.md"
      - ".github/workflows/**/*.yml"
      - ".github/workflows/**/*.yaml"
  push:
    paths:
      - "docs/**/*.md"
      - "ARCHITECTURE.md"
      - ".github/workflows/**/*.md"
      - ".github/workflows/**/*.yml"
      - ".github/workflows/**/*.yaml"

permissions:
  contents: read

concurrency:
  group: ai-behavior-check-${{ github.ref }}
  cancel-in-progress: true

jobs:
  ai_behavior_check:
    name: Repo hygiene and governed markdown gate
    runs-on: ubuntu-latest

    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.11"

      - name: Run behavior and hygiene checks
        shell: bash
        run: |
          python - <<'PY'
          import json
          import os
          import re
          import subprocess
          import sys
          from pathlib import Path

          REPO_ROOT = Path(".").resolve()

          # --- Config: what we consider "governed docs" for strict checks
          GOVERNED_MD_EXACT = {
              "ARCHITECTURE.md",
              ".github/workflows/README.md",
          }
          GOVERNED_MD_PREFIXES = (
              "docs/",
          )

          REQUIRED_FRONT_MATTER_KEYS = [
              "title",
              "path",
              "version",
              "last_updated",
              "status",
              "doc_kind",
              "license",
              "markdown_protocol_version",
              "mcp_version",
              "ontology_protocol_version",
              "pipeline_contract_version",
              "stac_profile",
              "dcat_profile",
              "prov_profile",
              "governance_ref",
              "ethics_ref",
              "sovereignty_policy",
              "fair_category",
              "care_label",
              "sensitivity",
              "classification",
              "jurisdiction",
              "doc_uuid",
              "semantic_document_id",
              "event_source_id",
              "commit_sha",
              "ai_transform_permissions",
              "ai_transform_prohibited",
              "doc_integrity_checksum",
          ]

          # Disallow chat artifacts and assistant meta text in committed files
          BANNED_PATTERNS = [
              (r"ÓàÄfileciteÓàÇ", "Chat citation token found (filecite)."),
              (r"\bturn\d+[a-z]+\d+\b", "Chat citation/turn reference found (turn*)."),
              (r"\bfile_search\b|\bweb\.run\b|\bpython_user_visible\b|\bsummary_reader\b", "Internal tool reference found."),
              (r"As an AI language model", "Assistant boilerplate found."),
              (r"\bI can(?:not|'t)\b", "Assistant refusal boilerplate found."),
              (r"\bplease wait\b|\bsit tight\b", "Assistant waiting language found."),
          ]

          def load_event() -> dict:
              p = os.environ.get("GITHUB_EVENT_PATH")
              if not p:
                  return {}
              try:
                  with open(p, "r", encoding="utf-8") as f:
                      return json.load(f)
              except Exception:
                  return {}

          def git_diff_files(base: str, head: str) -> list[str]:
              cmd = ["git", "diff", "--name-only", "--diff-filter=ACMRT", base, head]
              out = subprocess.check_output(cmd, text=True, encoding="utf-8", errors="replace")
              return [ln.strip() for ln in out.splitlines() if ln.strip()]

          def is_probably_text_file(path: Path) -> bool:
              try:
                  data = path.read_bytes()
              except Exception:
                  return False
              if b"\x00" in data:
                  return False
              # Treat very large files as out of scope for this lightweight gate
              if len(data) > 2_000_000:
                  return False
              return True

          def read_text(path: Path) -> str:
              return path.read_text(encoding="utf-8", errors="replace")

          def is_governed_markdown(rel: str) -> bool:
              if rel in GOVERNED_MD_EXACT:
                  return True
              return rel.endswith(".md") and rel.startswith(GOVERNED_MD_PREFIXES)

          def find_line_number(text: str, idx: int) -> int:
              return text.count("\n", 0, idx) + 1

          def check_banned_patterns(rel: str, text: str, errors: list[str]) -> None:
              for pat, msg in BANNED_PATTERNS:
                  for m in re.finditer(pat, text, flags=re.IGNORECASE | re.MULTILINE):
                      line = find_line_number(text, m.start())
                      errors.append(f"{rel}:{line}: {msg}")

          def extract_front_matter(text: str):
              lines = text.splitlines()
              if not lines or lines[0].strip() != "---":
                  return None, "Missing YAML front-matter start delimiter '---' on first line."
              end_idx = None
              for i in range(1, len(lines)):
                  if lines[i].strip() == "---":
                      end_idx = i
                      break
              if end_idx is None:
                  return None, "Missing YAML front-matter end delimiter '---'."
              block = "\n".join(lines[1:end_idx])
              return block, None

          def check_governed_markdown(rel: str, text: str, errors: list[str]) -> None:
              # 1) Require YAML front matter
              fm, fm_err = extract_front_matter(text)
              if fm_err:
                  errors.append(f"{rel}:1: {fm_err}")
                  return

              # 2) Require key fields in front matter (simple regex presence)
              for key in REQUIRED_FRONT_MATTER_KEYS:
                  if not re.search(rf"(?m)^{re.escape(key)}\s*:", fm):
                      errors.append(f"{rel}:1: Missing required front-matter key: {key}")

              # 3) Path field must match the file path
              m = re.search(r'(?m)^path\s*:\s*["\']?(.+?)["\']?\s*$', fm)
              if not m:
                  errors.append(f"{rel}:1: Missing or invalid 'path:' value in front matter.")
              else:
                  declared = m.group(1).strip()
                  if declared != rel:
                      errors.append(f"{rel}:1: Front-matter path mismatch. Declared '{declared}' != actual '{rel}'.")

              # 4) Governed docs prefer ~~~ fences over ``` fences
              if "```" in text:
                  errors.append(f"{rel}:1: Triple-backtick fences found. Use ~~~ fences for governed docs (KFM protocol).")

          def main() -> int:
              event = load_event()
              event_name = os.environ.get("GITHUB_EVENT_NAME", "")
              base = None
              head = None

              if event_name == "pull_request" and "pull_request" in event:
                  base = event["pull_request"]["base"]["sha"]
                  head = event["pull_request"]["head"]["sha"]
              elif event_name == "push":
                  base = event.get("before")
                  head = event.get("after") or os.environ.get("GITHUB_SHA")

              if base and head and base != "0" * 40:
                  changed = git_diff_files(base, head)
              else:
                  # Fallback: check all tracked files (rare, but safe)
                  out = subprocess.check_output(["git", "ls-files"], text=True, encoding="utf-8", errors="replace")
                  changed = [ln.strip() for ln in out.splitlines() if ln.strip()]

              errors: list[str] = []

              for rel in changed:
                  p = REPO_ROOT / rel
                  if not p.exists() or not p.is_file():
                      continue
                  if not is_probably_text_file(p):
                      continue

                  text = read_text(p)

                  # Global ban list checks for all text files
                  check_banned_patterns(rel, text, errors)

                  # Governed markdown checks
                  if is_governed_markdown(rel):
                      check_governed_markdown(rel, text, errors)

              if errors:
                  print("AI behavior / repo hygiene gate failed:\n")
                  for e in errors:
                      print(f"  - {e}")
                  print("\nFix the issues above and re-run CI.")
                  return 1

              print("AI behavior / repo hygiene gate passed.")
              return 0

          if __name__ == "__main__":
              sys.exit(main())
          PY
