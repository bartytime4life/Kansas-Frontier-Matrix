# .github/workflows/stac-validate.yml
name: STAC Validation

on:
  pull_request:
    branches: [ main ]
    paths:
      - "stac/**"
      - "data/sources/**"
      - "src/**"
      - "scripts/validate_stac.py"
      - "scripts/validate_sources.py"
      - "Makefile"
      - "requirements*.txt"
      - "pyproject.toml"
      - ".github/workflows/stac-validate.yml"
  push:
    branches: [ main ]
    paths:
      - "stac/**"
      - "data/sources/**"
      - "src/**"
      - "scripts/validate_stac.py"
      - "scripts/validate_sources.py"
      - "Makefile"
      - "requirements*.txt"
      - "pyproject.toml"
      - ".github/workflows/stac-validate.yml"
  workflow_dispatch:

permissions:
  contents: read

concurrency:
  group: stac-validate-${{ github.ref }}
  cancel-in-progress: true

jobs:
  validate:
    name: STAC validate (py${{ matrix.python-version }})
    runs-on: ubuntu-latest
    timeout-minutes: 20

    strategy:
      fail-fast: false
      matrix:
        python-version: ["3.10", "3.11", "3.12"]

    env:
      PYTHONUNBUFFERED: "1"

    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with: { fetch-depth: 0 }

      - name: Setup Python ${{ matrix.python-version }}
        uses: actions/setup-python@v5
        with:
          python-version: ${{ matrix.python-version }}
          cache: pip
          cache-dependency-path: |
            requirements*.txt
            pyproject.toml

      - name: Install system tools
        run: |
          sudo apt-get update
          sudo apt-get install -y --no-install-recommends jq
          # yamllint is pip-installed below; jq handles JSON quickly

      - name: Install Python deps (project + validators)
        run: |
          set -euo pipefail
          python -m pip install --upgrade pip
          # Try to expose console_scripts (e.g., kgt) if project is installable
          if [ -f pyproject.toml ] || [ -f setup.cfg ] || [ -f setup.py ]; then
            pip install -e ".[dev,validate]" || pip install -e . || true
          fi
          # Core validators regardless (quiet where safe)
          pip install --upgrade --quiet \
            jsonschema jinja2 pystac pystac-client pyyaml \
            stac-validator yamllint

          python - <<'PY'
import sys, jsonschema, pystac  # noqa
print("Python", sys.version.split()[0], "— deps OK")
PY

      # -------------------- Quick syntax checks --------------------
      - name: JSON syntax check (stac/**/*.json)
        run: |
          set -euo pipefail
          if [ -d stac ]; then
            shopt -s nullglob
            files=($(git ls-files 'stac/**/*.json' || true))
            if [ ${#files[@]} -gt 0 ]; then
              echo "Linting STAC JSON…"
              for f in "${files[@]}"; do
                jq -e . "$f" >/dev/null || { echo "::error file=$f::JSON parse error"; exit 1; }
              done
              echo "stac/**/*.json ✔ valid JSON"
            else
              echo "No STAC JSON files found by git ls-files."
            fi
          else
            echo "::notice::stac/ not present; skipping."
          fi

      - name: JSON/YAML syntax check (data/sources/**)
        run: |
          set -euo pipefail
          if [ -d data/sources ]; then
            echo "Linting data/sources (JSON)…"
            find data/sources -type f -name '*.json' -print0 | xargs -0 -r -I{} sh -c 'jq -e . "{}" >/dev/null || (echo "::error file={}" "JSON parse error" && exit 1)'

            echo "Linting data/sources (YAML)…"
            # yamllint: strict for syntax; relaxed for style
            if command -v yamllint >/dev/null 2>&1; then
              yamllint -s -f standard data/sources || {
                echo "::warning title=YAML style issues::yamllint reported style problems (not failing the build)."
              }
            fi

            python - <<'PY'
import sys, pathlib, yaml
base = pathlib.Path("data/sources")
bad=[]
for p in list(base.rglob("*.yml")) + list(base.rglob("*.yaml")):
    try:
        yaml.safe_load(p.read_text(encoding="utf-8"))
    except Exception as e:
        bad.append((str(p), str(e)))
if bad:
    for f,e in bad:
        print(f"::error file={f}::YAML parse error: {e}")
    sys.exit(1)
else:
    print("data/sources/** ✔ valid YAML")
PY
          else
            echo "::notice::data/sources/ not present; skipping."
          fi

      # -------------------- Custom repo validators --------------------
      - name: Run scripts/validate_sources.py (if present)
        run: |
          set -euo pipefail
          if [ -f scripts/validate_sources.py ]; then
            python scripts/validate_sources.py
          else
            echo "::notice::scripts/validate_sources.py not found; skipping."
          fi

      - name: Run scripts/validate_stac.py (if present)
        id: script_stac
        continue-on-error: true
        run: |
          set -euo pipefail
          mkdir -p build
          if [ -f scripts/validate_stac.py ]; then
            python scripts/validate_stac.py --report build/stac_report.json
          else
            echo "::notice::scripts/validate_stac.py not found; using fallback."
          fi

      # -------------------- STAC validation (robust) --------------------
      - name: Validate STAC with stac-validator (preferred)
        id: stac_cli
        continue-on-error: true
        run: |
          set -euo pipefail
          mkdir -p build
          if [ -d stac ]; then
            if [ -f stac/catalog.json ]; then
              echo "Validating stac/catalog.json (recursive)…"
              stac-validator stac/catalog.json --recursive --links | tee build/stac_validator.txt
            else
              echo "Validating all STAC JSON files…"
              set +e
              ok=1
              for f in $(find stac -type f -name '*.json' | sort); do
                stac-validator "$f" >> build/stac_validator.txt 2>&1 || ok=0
              done
              set -e
              [ $ok -eq 1 ] || exit 2
            fi
          else
            echo "::notice::No stac/ directory; skipping stac-validator."
          fi

      - name: Validate STAC with pystac (fallback)
        if: steps.stac_cli.outcome == 'failure' || steps.stac_cli.outcome == 'skipped'
        run: |
          set -euo pipefail
          if [ -f stac/catalog.json ]; then
            python - <<'PY'
import pystac, sys
try:
    cat = pystac.Catalog.from_file("stac/catalog.json")
    cat.normalize_hrefs("stac")
    cat.validate_all()
    print("pystac: catalog/collections validate OK")
except Exception as e:
    print(f"::error::pystac validation failed: {e}")
    sys.exit(2)
PY
          else
            echo "::notice::No stac/catalog.json; running file-by-file pystac checks."
            python - <<'PY'
import sys, pathlib, pystac
root = pathlib.Path("stac")
if not root.exists():
    print("::notice::No stac directory; skip pystac.")
    sys.exit(0)
bad=[]
for p in sorted(root.rglob("*.json")):
    try:
        pystac.read_file(str(p)).validate()
    except Exception as e:
        bad.append((str(p), str(e)))
if bad:
    for f,e in bad:
        print(f"::error file={f}::{e}")
    sys.exit(2)
print("All STAC JSON passed pystac validation")
PY
          fi

      # -------------------- Fallback item structure (only if no report) --------------------
      - name: Fallback STAC item structure check
        if: |
          !cancelled() && hashFiles('build/stac_report.json') == ''
        run: |
          set -euo pipefail
          python - <<'PY'
import json, pathlib, sys
items_dir = pathlib.Path("stac/items")
path_build = pathlib.Path("build"); path_build.mkdir(exist_ok=True)
report_path = path_build/"stac_report.json"
if not items_dir.exists():
    print("::notice::stac/items not present; skipping item validation.")
    report_path.write_text(json.dumps({"valid":0,"invalid":0,"items":[]}, indent=2))
    sys.exit(0)
req = ["stac_version","id","type","geometry","bbox","properties","links","assets"]
ok=bad=0; report=[]
for p in items_dir.rglob("*.json"):
    try:
        d=json.loads(p.read_text(encoding="utf-8"))
    except Exception as e:
        report.append({"id": str(p), "valid": False, "errors":[{"path":[],"message":str(e)}]}); bad+=1; continue
    errs=[]
    missing=[k for k in req if k not in d]
    if missing: errs.append(f"missing {missing}")
    if d.get("type")!="Feature": errs.append("type must be 'Feature'")
    if errs:
        bad+=1
        report.append({"id":d.get("id",str(p)),"valid":False,"errors":[{"path":[],"message":"; ".join(errs)}]})
    else:
        ok+=1
        report.append({"id":d.get("id",str(p)),"valid":True,"errors":[]})
report_path.write_text(json.dumps({"valid":ok,"invalid":bad,"items":report}, indent=2))
print(f"[RESULT] {ok} valid, {bad} invalid")
if bad>0: sys.exit(2)
PY

      # -------------------- Summaries & artifacts --------------------
      - name: Summarize results
        if: always()
        run: |
          set -euo pipefail
          {
            echo "## STAC Validation"
            if [ -f build/stac_report.json ]; then
              python - <<'PY'
import json, pathlib
p = pathlib.Path("build/stac_report.json")
d = json.loads(p.read_text()) if p.exists() else {}
ok, bad = d.get("valid",0), d.get("invalid",0)
print(f"- ✅ Valid items: **{ok}**")
print(f"- ❌ Invalid items: **{bad}**")
if bad:
    print("\n<details><summary>First 10 errors</summary>\n")
    cnt=0
    for it in d.get('items', []):
        if it.get('valid') is False and cnt<10:
            msgs = ', '.join(e.get('message','') for e in it.get('errors',[])[:3])
            print(f"- **{it.get('id')}** — {msgs}")
            cnt+=1
    print("\n</details>")
PY
            else
              echo "- No STAC item report generated."
            fi
          } >> "$GITHUB_STEP_SUMMARY"

      - name: Upload reports
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: stac-validate-reports-py${{ matrix.python-version }}-${{ github.run_id }}
          path: |
            build/**
            ./*.log
            ./stac_validator.txt
          if-no-files-found: ignore
          retention-days: 10