name: Build & Attach Release Artifacts

on:
  push:
    tags: [ "v*" ]
  workflow_dispatch:

permissions:
  contents: write

concurrency:
  group: "release-${{ github.ref }}"
  cancel-in-progress: true

env:
  PYTHON_VERSION: "3.11"
  DIST_DIR: dist
  EXTRAS_DIR: build/extras
  PIP_DISABLE_PIP_VERSION_CHECK: "1"
  PIP_NO_PYTHON_VERSION_WARNING: "1"

jobs:
  build:
    name: Build (sdist+wheel) & validate
    runs-on: ubuntu-latest

    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0   # setuptools_scm needs tags/history

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: ${{ env.PYTHON_VERSION }}
          cache: pip
          cache-dependency-path: |
            requirements*.txt
            pyproject.toml

      - name: Install build toolchain
        run: |
          python -m pip install --upgrade pip
          pip install build twine setuptools_scm packaging

      # Ensure the tag (vX.Y.Z...) matches the project version resolved by setuptools_scm.
      - name: Verify tag matches project version
        id: tagcheck
        run: |
          set -euo pipefail
          TAG="${GITHUB_REF_NAME#v}"          # strip leading 'v'
          PYVER="$(python - <<'PY'
from setuptools_scm import get_version
from packaging.version import Version
print(Version(get_version()).public)
PY
)"
          echo "Tag: ${TAG}"
          echo "Resolved version: ${PYVER}"
          # Allow exact match. If you use pre/post releases, tag should include them (e.g., v1.2.0rc1).
          if [ "${TAG}" != "${PYVER}" ]; then
            echo "::error::Git tag (${TAG}) does not match project version (${PYVER})"
            exit 1
          fi
          echo "version=${PYVER}" >> "$GITHUB_OUTPUT"

      # Optional, light smoke: try import after editable install w/o heavy deps
      - name: Quick smoke (editable, no-deps)
        run: |
          set -euo pipefail
          pip install -e . --no-deps || true
          python - <<'PY'
import importlib, sys
mods = ["kansas_geo_timeline"]
for m in mods:
    try:
        importlib.import_module(m)
        print(f"[ok] import {m}")
    except Exception as e:
        print(f"[warn] cannot import {m} without deps: {e}", file=sys.stderr)
PY

      - name: Build sdist & wheel
        run: |
          python -m build
          ls -lh "${{ env.DIST_DIR }}/"

      - name: Twine check
        run: python -m twine check ${{ env.DIST_DIR }}/*

      - name: Bundle extras (optional)
        run: |
          set -euo pipefail
          mkdir -p "${EXTRAS_DIR}"
          if [ -d stac ]; then
            (cd stac && zip -qr "../${EXTRAS_DIR}/stac_snapshot.zip" .)
          fi
          if [ -d web ]; then
            (cd web && zip -qr "../${EXTRAS_DIR}/web_snapshot.zip" .)
          fi
          [ -d "${EXTRAS_DIR}" ] && ls -lh "${EXTRAS_DIR}" || true

      - name: Checksums (SHA-256)
        run: |
          set -euo pipefail
          shopt -s nullglob
          for f in "${DIST_DIR}"/*; do
            [ -e "$f" ] || continue
            sha256sum "$f" | tee "$f.sha256"
          done
          if [ -d "${EXTRAS_DIR}" ]; then
            for f in "${EXTRAS_DIR}"/*.zip; do
              [ -e "$f" ] || continue
              sha256sum "$f" | tee "$f.sha256"
            done
          fi
          # Produce a manifest for easy verification in the Release body
          {
            echo "# SHA-256 checksums"
            echo
            for f in "${DIST_DIR}"/*; do [ -e "$f.sha256" ] && echo "$(cat "$f.sha256")"; done
            if [ -d "${EXTRAS_DIR}" ]; then
              for f in "${EXTRAS_DIR}"/*.sha256; do [ -e "$f" ] && cat "$f"; done
            fi
          } > CHECKSUMS.txt
          ls -lh CHECKSUMS.txt

      - name: Upload build artifacts
        uses: actions/upload-artifact@v4
        with:
          name: dist
          path: |
            ${{ env.DIST_DIR }}/*
            ${{ env.DIST_DIR }}/*.sha256
            ${{ env.EXTRAS_DIR }}/*.zip
            ${{ env.EXTRAS_DIR }}/*.sha256
            CHECKSUMS.txt
          if-no-files-found: warn
          retention-days: 7

      - name: Job summary (hashes)
        run: |
          {
            echo "## Release artifacts"
            echo ""
            echo "### dist/"
            ls -lh ${{ env.DIST_DIR }} || true
            if [ -d "${EXTRAS_DIR}" ]; then
              echo ""
              echo "### ${EXTRAS_DIR}/"
              ls -lh ${EXTRAS_DIR} || true
            fi
            echo ""
            echo "### Checksums"
            echo '```'
            sed -n '1,200p' CHECKSUMS.txt
            echo '```'
          } >> "$GITHUB_STEP_SUMMARY"

  github-release:
    name: Create GitHub Release
    needs: build
    runs-on: ubuntu-latest
    permissions:
      contents: write

    steps:
      - name: Download artifacts
        uses: actions/download-artifact@v4
        with:
          name: dist
          path: dist

      - name: Verify artifacts exist
        run: |
          set -euo pipefail
          shopt -s nullglob
          cnt=$(find dist -type f | wc -l | tr -d ' ')
          if [ "$cnt" = "0" ]; then
            echo "::error::No release artifacts found in dist/"
            exit 1
          fi
          echo "Found $cnt artifact(s) in dist/"

      - name: Detect prerelease from tag
        id: prerelease
        run: |
          tag="${GITHUB_REF_NAME}"
          shopt -s nocasematch
          if [[ "$tag" =~ rc|beta|alpha ]]; then
            echo "is_prerelease=true" >> "$GITHUB_OUTPUT"
          else
            echo "is_prerelease=false" >> "$GITHUB_OUTPUT"
          fi

      - name: Create GitHub Release
        uses: softprops/action-gh-release@v2
        with:
          files: |
            dist/**
          draft: false
          prerelease: ${{ steps.prerelease.outputs.is_prerelease }}
          generate_release_notes: true
          body_path: dist/CHECKSUMS.txt
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
