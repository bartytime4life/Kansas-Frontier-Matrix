# .github/workflows/stac.yml
name: STAC & Config

on:
  push:
    branches: [ main ]
    paths:
      - "stac/**"
      - "src/**"
      - "web/**"
      - "pyproject.toml"
      - "requirements*.txt"
      - ".github/workflows/stac.yml"
  pull_request:
    branches: [ main ]
    paths:
      - "stac/**"
      - "src/**"
      - "web/**"
      - "pyproject.toml"
      - "requirements*.txt"
      - ".github/workflows/stac.yml"
  workflow_dispatch:

permissions:
  contents: read

concurrency:
  group: stac-${{ github.ref }}
  cancel-in-progress: true

jobs:
  validate-and-render:
    name: Validate STAC & Render app.config.json
    runs-on: ubuntu-latest
    timeout-minutes: 20
    env:
      PYTHONUNBUFFERED: "1"

    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with: { fetch-depth: 0 }

      - name: Install jq
        run: |
          sudo apt-get update -y
          sudo apt-get install -y --no-install-recommends jq

      # ---------- Fast JSON lint (web + STAC) ----------
      - name: Validate JSON syntax (configs & STAC)
        shell: bash
        run: |
          set -euo pipefail
          shopt -s nullglob globstar
          summary="### JSON syntax check\n"
          fail=0
          check() {
            local f="$1"
            if jq -e . "$f" >/dev/null 2>&1; then
              summary+="- ✅ $f\n"
            else
              summary+="- ❌ $f\n"
              echo "::error file=$f::Invalid JSON"
              fail=1
            fi
          }
          for f in web/app.config.json web/layers.json web/config/**/*.json; do [ -e "$f" ] && check "$f"; done
          for f in stac/**/*.json; do [ -e "$f" ] && check "$f"; done
          echo -e "$summary" >> "$GITHUB_STEP_SUMMARY"
          exit $fail

      # ---------- Python toolchain ----------
      - name: Set up Python 3.11
        uses: actions/setup-python@v5
        with:
          python-version: "3.11"
          cache: "pip"
          cache-dependency-path: |
            pyproject.toml
            requirements*.txt

      - name: Install dependencies (CLI + validators)
        run: |
          set -euo pipefail
          python -m pip install --upgrade pip
          if [ -f requirements-dev.txt ]; then
            pip install -r requirements-dev.txt
          elif [ -f requirements.txt ]; then
            pip install -r requirements.txt
          fi
          # Deterministic core validators
          pip install "jsonschema>=4.19,<5" "jinja2>=3.1,<4" "pystac>=1.9,<2" "stac-validator>=3.0,<4"
          # Install project (editable) so console_scripts like `kgt` resolve if provided
          if [ -f pyproject.toml ] || [ -f setup.cfg ] || [ -f setup.py ]; then
            pip install -e ".[dev]" || pip install -e .
          fi
          python - <<'PY'
import sys, jsonschema, pystac
print("Python:", sys.version.split()[0])
print("jsonschema:", jsonschema.__version__)
print("pystac:", getattr(pystac, "__version__", "n/a"))
PY

      # ---------- Detect renderer ----------
      - name: Detect renderer/CLI
        id: detect_cli
        shell: bash
        run: |
          set -euo pipefail
          if command -v kgt >/dev/null 2>&1; then
            echo "renderer=kgt" >> "$GITHUB_OUTPUT"
          elif python - <<'PY'; then
import importlib.util, sys
sys.exit(0 if importlib.util.find_spec('src.kansas_geo_timeline.cli') or
             importlib.util.find_spec('kansas_geo_timeline.cli') else 3)
PY
            echo "renderer=module" >> "$GITHUB_OUTPUT"
          else
            echo "renderer=none" >> "$GITHUB_OUTPUT"
            echo "::notice title=Renderer not found::Neither 'kgt' nor module CLI available; will skip render unless app.config.json already exists."
          fi

      # ---------- STAC validate (prefer CLI, fallback to pystac) ----------
      - name: Validate STAC
        id: stac_validate
        shell: bash
        run: |
          set -euo pipefail
          mkdir -p .artifacts
          summary="### STAC validation\n"
          if [ ! -d stac ]; then
            echo "::notice::No stac/ directory; skipping STAC validation."
            echo -e "$summary- ⚠️ no stac/ directory\n" >> "$GITHUB_STEP_SUMMARY"
            printf '{"status":"skip"}' > .artifacts/stac_report.json
            exit 0
          fi
          if command -v stac-validator >/dev/null 2>&1; then
            if [ -f stac/catalog.json ]; then
              echo "Validating catalog recursively with stac-validator…"
              if stac-validator stac/catalog.json --recursive --links | tee .artifacts/stac_validator.txt; then
                summary+="- ✅ stac/catalog.json (recursive)\n"
              else
                summary+="- ❌ stac/catalog.json (recursive)\n"
                echo -e "$summary" >> "$GITHUB_STEP_SUMMARY"
                exit 2
              fi
            else
              echo "Validating all STAC JSON files…"
              set +e; ok=1
              while IFS= read -r -d '' f; do
                stac-validator "$f" >> .artifacts/stac_validator.txt 2>&1 || ok=0
              done < <(find stac -type f -name '*.json' -print0 | sort -z)
              set -e
              [ $ok -eq 1 ] && summary+="- ✅ stac/**/*.json\n" || { summary+="- ❌ stac/**/*.json (see artifact)\n"; echo -e "$summary" >> "$GITHUB_STEP_SUMMARY"; exit 2; }
            fi
          else
            echo "stac-validator not available; using pystac fallback…"
            python - <<'PY'
import sys, pathlib, pystac
root = pathlib.Path("stac")
bad=[]
for p in sorted(root.rglob("*.json")):
    try:
        pystac.read_file(str(p)).validate()
    except Exception as e:
        bad.append((str(p), str(e)))
if bad:
    for f,e in bad[:25]:
        print(f"::error file={f}::{e}")
    sys.exit(2)
print("pystac: all STAC JSON validate OK")
PY
            summary+="- ✅ pystac validation\n"
          fi
          echo -e "$summary" >> "$GITHUB_STEP_SUMMARY"
          printf '{"status":"ok"}' > .artifacts/stac_report.json

      # ---------- Render app.config.json from STAC (if possible) ----------
      - name: Render web/app.config.json (from STAC)
        id: render_app_cfg
        shell: bash
        run: |
          set -euo pipefail
          case "${{ steps.detect_cli.outputs.renderer }}" in
            kgt)
              kgt render-config --stac stac/items --output web/app.config.json --pretty
              ;;
            module)
              # Try canonical module path first, then src.-prefixed
              python - <<'PY'
import runpy, sys
try:
    runpy.run_module("kansas_geo_timeline.cli", run_name="__main__")
except ModuleNotFoundError:
    runpy.run_module("src.kansas_geo_timeline.cli", run_name="__main__")
PY
              # If the CLI above takes args normally, prefer this call:
              # python -m kansas_geo_timeline.cli render-config --stac stac/items --output web/app.config.json --pretty || \
              # python -m src.kansas_geo_timeline.cli render-config --stac stac/items --output web/app.config.json --pretty
              ;;
            *)
              if [ -f web/app.config.json ]; then
                echo "::notice title=Renderer unavailable::Using existing web/app.config.json"
              else
                echo "::notice title=No renderer::Skipping render step"
              fi
              ;;
          esac
          if [ -f web/app.config.json ]; then
            jq -e . web/app.config.json >/dev/null
            echo "### Render" >> "$GITHUB_STEP_SUMMARY"
            echo "- ✅ web/app.config.json rendered/validated" >> "$GITHUB_STEP_SUMMARY"
          fi

      # ---------- Schema checks (if schemas exist) ----------
      - name: Schema-validate app.config.json (if schema present)
        if: always()
        run: |
          set -euo pipefail
          if [ -f web/app.config.json ] && [ -f web/config/app.config.schema.json ]; then
            python - <<'PY'
import json, sys
from jsonschema import Draft202012Validator
cfg = json.load(open("web/app.config.json", encoding="utf-8"))
sch = json.load(open("web/config/app.config.schema.json", encoding="utf-8"))
errs = sorted(Draft202012Validator(sch).iter_errors(cfg), key=lambda e: e.path)
if errs:
    for e in errs[:25]:
        print(f"- {'/'.join(map(str,e.path)) or '(root)'}: {e.message}")
    sys.exit(2)
print("app.config.json ✔ schema-valid")
PY
          else
            echo "::notice title=Schema or config missing::Skipped app.config.json schema validation"
          fi

      - name: Schema-validate layers.json (if present)
        if: always()
        run: |
          set -euo pipefail
          if [ -f web/layers.json ] && [ -f web/config/layers.schema.json ]; then
            python - <<'PY'
import json, sys
from jsonschema import Draft202012Validator
cfg = json.load(open("web/layers.json", encoding="utf-8"))
sch = json.load(open("web/config/layers.schema.json", encoding="utf-8"))
errs = sorted(Draft202012Validator(sch).iter_errors(cfg), key=lambda e: e.path)
if errs:
    for e in errs[:25]:
        print(f"- {'/'.join(map(str,e.path)) or '(root)'}: {e.message}")
    sys.exit(2)
print("layers.json ✔ schema-valid")
PY
          else
            echo "::notice title=Schema or layers missing::Skipped layers.json schema validation"
          fi

      # ---------- Artifacts ----------
      - name: Upload artifacts
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: stac-${{ github.run_id }}
          path: |
            .artifacts/stac_report.json
            .artifacts/stac_validator.txt
            web/app.config.json
          if-no-files-found: warn
          retention-days: 14