import os

base_path = "/mnt/data/src/pipelines/architecture/architecture_diagrams"
os.makedirs(base_path, exist_ok=True)

content = """%% Kansas Frontier Matrix (KFM) — Idempotency Flow (v11)
%% File: src/pipelines/architecture/architecture_diagrams/idempotency_flow.mmd
%% Purpose:
%% - Show how KFM pipelines stay replayable + idempotent across ETL, catalogs, governance, and graph load
%% - Highlight diffing, atomic writes, versioned outputs, append-only ledgers, and safe re-runs

flowchart TB

  %% ------------------------------------------------------------
  %% Triggers
  %% ------------------------------------------------------------
  subgraph TRIGGERS["Triggers"]
    T_CLI["CLI / local operator run"]
    T_CI["CI/CD run (PR/merge)"]
    T_SCHED["Scheduled backfill / refresh"]
  end

  %% ------------------------------------------------------------
  %% Deterministic planning
  %% ------------------------------------------------------------
  subgraph PLANNING["Run planning (deterministic)"]
    P_CFG["Load pipeline config"]
    P_PIN["Pin tool versions + environment"]
    P_SIG["Compute run signature\\n(inputs + config + tool versions)"]
    P_RUNID["Create run_id + snapshot\\n(mcp/runs/{run_id}/config + env + seeds)"]
    P_DIFF["Diff inputs\\n(checksums/manifests; new vs changed vs unchanged)"]
    P_PLAN["Build work plan\\n(replayable; idempotent steps)"]
  end

  %% ------------------------------------------------------------
  %% Skip / no-op path
  %% ------------------------------------------------------------
  subgraph NOOP["No-op path (idempotent)"]
    N_SKIP["Skip heavy work\\n(no changes detected)"]
    N_RECORD["Emit no-op record\\n(telemetry + ledger entry)"]
  end

  %% ------------------------------------------------------------
  %% Extract (replayable)
  %% ------------------------------------------------------------
  subgraph EXTRACT["Extract (replayable)"]
    E_FETCH["Fetch raw artifacts\\n(if missing)"]
    E_RAW["Write raw\\n(data/raw/{source_id}/**)"]
    E_HASH["Verify/compute sha256\\n(data/checksums/**)"]
  end

  %% ------------------------------------------------------------
  %% Transform (idempotent outputs)
  %% ------------------------------------------------------------
  subgraph TRANSFORM["Transform (deterministic + idempotent outputs)"]
    X_STAGE["Stage workspace\\n(data/work/{run_id}/**)"]
    X_PROC["Deterministic transforms\\n(parse/clean/georef/normalize)"]
    X_ATOMIC["Atomic write\\n(temp → final)"]
    X_OUT["Processed outputs\\n(data/processed/{dataset_id}/{version}/**)"]
  end

  %% ------------------------------------------------------------
  %% Catalog + provenance
  %% ------------------------------------------------------------
  subgraph CATALOG["Catalog + provenance (stable identifiers)"]
    C_STAC["Upsert STAC\\n(data/stac/**; stable ids; linked assets)"]
    C_DCAT["Update DCAT view\\n(dataset/distribution metadata)"]
    C_PROV["Write PROV trace\\n(used/generated/associatedWith)"]
  end

  %% ------------------------------------------------------------
  %% Validation gates
  %% ------------------------------------------------------------
  subgraph VALIDATION["Validation gates (CI-blocking)"]
    V_SCHEMA["Schema validation\\n(STAC/DCAT/GeoJSON/telemetry)"]
    V_PARITY["Checksum parity\\n(raw/processed/assets)"]
    V_OK{"Valid + compliant?"}
    V_FAIL["Stop + report\\n(data/reports/**; preserve run context)"]
  end

  %% ------------------------------------------------------------
  %% Governance (append-only)
  %% ------------------------------------------------------------
  subgraph GOVERNANCE["Governance (append-only)"]
    G_LEDGER["Append-only ledger update\\n(run_id + hashes + decision)"]
    G_CERT["Certification state\\n(certified / provisional / blocked)"]
    G_TELEM["Telemetry record\\n(non-PII; energy/carbon where enabled)"]
    G_RELEASE["Release artifacts\\n(manifest.zip + sbom.spdx.json + attestations)"]
  end

  %% ------------------------------------------------------------
  %% Idempotent load
  %% ------------------------------------------------------------
  subgraph LOAD["Idempotent load + serve"]
    L_GRAPH["Neo4j upsert/merge\\n(constraints + stable URNs)"]
    L_DEDUPE["Dedupe + version-aware merge\\n(nodes/edges; incremental ingest)"]
    L_API["API serves governed data\\n(contracted responses)"]
    L_WEB["Web UI consumes APIs only\\n(no raw-file reads)"]
  end

  %% ------------------------------------------------------------
  %% Wiring
  %% ------------------------------------------------------------
  T_CLI --> P_CFG
  T_CI --> P_CFG
  T_SCHED --> P_CFG

  P_CFG --> P_PIN --> P_SIG --> P_RUNID --> P_DIFF --> P_PLAN

  %% plan splits
  P_PLAN -->|unchanged| N_SKIP --> N_RECORD --> G_LEDGER
  P_PLAN -->|new/changed| E_FETCH

  %% extract
  E_FETCH --> E_RAW --> E_HASH --> X_STAGE

  %% transform
  X_STAGE --> X_PROC --> X_ATOMIC --> X_OUT

  %% catalog + provenance
  X_OUT --> C_STAC
  X_OUT --> C_DCAT
  X_OUT --> C_PROV

  %% validate
  C_STAC --> V_SCHEMA
  C_DCAT --> V_SCHEMA
  X_OUT --> V_PARITY
  C_PROV --> V_PARITY
  V_SCHEMA --> V_OK
  V_PARITY --> V_OK

  V_OK -- "no" --> V_FAIL
  V_OK -- "yes" --> G_LEDGER

  %% governance outputs
  G_LEDGER --> G_CERT --> G_TELEM --> G_RELEASE

  %% load + serve
  G_RELEASE --> L_GRAPH --> L_DEDUPE --> L_API --> L_WEB

  %% failure loop (safe reruns)
  V_FAIL --> P_RUNID
"""

file_path = os.path.join(base_path, "idempotency_flow.mmd")
with open(file_path, "w", encoding="utf-8") as f:
    f.write(content)

file_path
