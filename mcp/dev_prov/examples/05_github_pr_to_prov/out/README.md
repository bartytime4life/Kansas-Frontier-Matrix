# ğŸ§¾ Example 05 â€” GitHub PR âœ PROV (ğŸ“¦ Output Snapshot)

![Example](https://img.shields.io/badge/example-05-blue)
![Provenance](https://img.shields.io/badge/W3C-PROV--O-informational)
![KFM](https://img.shields.io/badge/KFM-provenance--first-orange)
![GitOps](https://img.shields.io/badge/GitOps-PR%20as%20gate-success)
![Graph](https://img.shields.io/badge/graph-Neo4j-black)

> âš ï¸ **Generated folder**: treat `out/` like a build artifact / golden fixture.  
> âœ… If anything here looks â€œwrongâ€, **change the generator upstream** (in the example) and re-run â€” **donâ€™t hand-edit outputs**.

---

## ğŸ§­ What this example demonstrates

This example captures **GitHub Pull Request lifecycle events as W3C PROV-O** so development history becomes **first-class lineage** â€” queryable the same way KFM treats datasets, pipelines, models, and story evidence.

In plain terms:

- ğŸ§‘â€ğŸ’» **Authors / Reviewers / CI Bots** âœ `prov:Agent`
- ğŸ§¾ **The Pull Request** âœ `prov:Activity`
- ğŸ§± **Commits / diffs / produced artifacts** âœ `prov:Entity`
- ğŸ”— **Relationships** such as:
  - `prov:used` (PR used commits)
  - `prov:wasAssociatedWith` (PR associated with author / bot)
  - `prov:wasGeneratedBy` (merge commit generated by PR activity)

---

## ğŸ—‚ï¸ Output layout

> Your exact filenames may vary depending on the runner, but the **roles** below are the intent.

```text
ğŸ“ out/
â”œâ”€ ğŸ§¾ README.md
â”œâ”€ ğŸªª pr.snapshot.json
â”œâ”€ ğŸ§¬ prov.pr.jsonld
â”œâ”€ ğŸ¢ prov.pr.ttl
â”œâ”€ ğŸ§· run.manifest.json
â””â”€ âœ… checks.report.json
```

### ğŸ“„ What each file is for

| File | What it contains | Why it exists |
|---|---|---|
| `pr.snapshot.json` | Normalized PR payload (IDs, timestamps, authors/reviewers, commits, labels, links) | Stable, repeatable input for provenance & QA |
| `prov.pr.jsonld` | **Primary provenance artifact** in PROV JSON-LD | Canonical record that can be ingested into graph storage |
| `prov.pr.ttl` | Optional Turtle serialization | Useful for RDF tooling & diff readability |
| `run.manifest.json` | Deterministic â€œrun ledgerâ€ (inputs, tool versions, hashes/digests, idempotency key) | Reproducibility + supply-chain confidence |
| `checks.report.json` | Invariants / sanity checks (ex: merge commit exists, commit ancestry consistent) | Fail-fast validation + CI gate material |

---

## ğŸ§© Canonical mapping rules: GitHub âœ PROV-O

| GitHub concept | PROV-O type | Suggested ID shape (example) |
|---|---|---|
| Pull Request `#123` | `prov:Activity` | `kfm:github/pr/<org>/<repo>/123` |
| PR â€œopenedâ€, â€œmergedâ€, â€œclosedâ€ events | `prov:Activity` (or sub-activities) | `kfm:github/pr_event/<event_id>` |
| Commit `abc123â€¦` | `prov:Entity` | `kfm:github/commit/abc123â€¦` |
| Merge commit `def456â€¦` | `prov:Entity` | `kfm:github/merge_commit/def456â€¦` |
| PR author `@alice` | `prov:Agent` | `kfm:github/user/alice` |
| Reviewer `@bob` | `prov:Agent` | `kfm:github/user/bob` |
| GitHub Actions bot / CI identity | `prov:Agent` | `kfm:github/ci/<workflow>/<run_id>` |

### ğŸ”— Core relationships (minimum viable PROV)

- `prov:used(PR_Activity, Commit_Entity)`
- `prov:wasAssociatedWith(PR_Activity, Author_Agent)`
- `prov:wasAssociatedWith(PR_Activity, CI_Agent)` *(if automation opened/updated it)*
- `prov:wasGeneratedBy(MergeCommit_Entity, PR_Activity)`
- (Optional) `prov:actedOnBehalfOf(Reviewer_Agent, Maintainers_Agent)`
- (Optional) `prov:wasInfluencedBy(PR_Activity, Issue_Entity)` *(links PR to a ticket / watcher alert)*

---

## ğŸ§¬ PROV graph sketch (Mermaid)

<details>
<summary>Click to expand</summary>

```mermaid
graph TD
  A[prov:Activity<br/>PR #123] -->|prov:used| C1[prov:Entity<br/>commit abc123]
  A -->|prov:used| C2[prov:Entity<br/>commit bcd234]
  A -->|prov:wasAssociatedWith| U1[prov:Agent<br/>@author]
  A -->|prov:wasAssociatedWith| CI[prov:Agent<br/>CI / GitHub Actions]

  MC[prov:Entity<br/>merge commit def456] -->|prov:wasGeneratedBy| A

  R1[prov:Agent<br/>@reviewer] -->|prov:actedOnBehalfOf| Maint[prov:Agent<br/>KFM Maintainers]
```

</details>

---

## ğŸ”— Where this plugs into KFM

### 1) ğŸ§  Knowledge graph lineage (Neo4j)
Once ingested, this provenance allows queries like:

- â€œWhich PR last modified the **water-quality pipeline**?â€
- â€œWhich PR produced the dataset currently powering **Layer X**?â€
- â€œShow all merged PRs that touched **hydrology model outputs** and list reviewers.â€

### 2) âœ… Governance & CI (fail-closed)
The PRâ†’PROV artifact becomes a **machine-checkable record** that policies can validate:
- PR-level invariants (merge commit exists, commit ancestry makes sense, required metadata present)
- KFM-wide invariants (e.g., â€œprocessed outputs changed âœ provenance updatedâ€, â€œno mystery layersâ€, etc.)

### 3) ğŸ—ºï¸ UI provenance surfacing
KFMâ€™s UI philosophy is â€œthe map behind the mapâ€ â€” layers and AI outputs should surface provenance context.  
This PRâ†’PROV output is a **backend-friendly** way to power:
- â€œView lineageâ€ buttons
- â€œWhich change introduced this layer?â€ panels
- Export credits / audit receipts

### 4) ğŸ¤– AI & explainability
KFMâ€™s AI/Focus workflows can point to â€œhow this dataset/layer changedâ€ by traversing:
`dataset prov âœ pipeline activity âœ PR activity âœ commits âœ authors/reviewers`

---

## âœ… Invariants this output is designed to support

These are examples of what `checks.report.json` (or policy gates) can enforce:

- âœ… A **merged PR** must produce a **merge commit** entity and link it via `prov:wasGeneratedBy`.
- âœ… Every commit included in the PR must be connected via `prov:used`.
- âœ… PR activity must be linked to at least one responsible agent via `prov:wasAssociatedWith`.
- âœ… Optional: ensure the merge commit is derived from the expected source commits (ancestry consistency).
- âœ… Optional: ensure policy-required metadata exists (licenses, classifications, provenance coverage).

---

## ğŸ” Integrity & packaging notes (optional but recommended)

If you treat provenance artifacts as â€œsupply-chain receiptsâ€, you can also:

- ğŸ“Œ Content-address outputs (hashes/digests)
- âœï¸ Sign run manifests / provenance with CI identity
- ğŸ“¦ Attach PROV JSON-LD as an artifact referrer when distributing large datasets via registries

This keeps the same discipline for **data artifacts** as for **container images**: versioned, reviewable, verifiable.

---

## ğŸ§ª Regenerating this folder

General workflow (adapt to your runner):

1) ğŸ“¥ Export PR payload  
2) âš™ï¸ Run the PRâ†’PROV converter  
3) ğŸ§¾ Validate JSON-LD + invariants  
4) ğŸ§  (Optional) ingest into Neo4j graph  
5) ğŸ§© (Optional) link dataset/proc PROV to PR PROV for full lineage

> Tip: keep outputs deterministic (stable ordering, canonical JSON, fixed timestamps where appropriate) so diffs remain meaningful in PR reviews.

---

## ğŸ§  Mini glossary

- **Entity** (`prov:Entity`) â€” a thing (commit, merge commit, file artifact)
- **Activity** (`prov:Activity`) â€” a process or event (PR lifecycle, ingestion run)
- **Agent** (`prov:Agent`) â€” who/what acted (human, CI bot, service identity)
- **Evidence manifest** â€” structured list of supporting artifacts for a claim/story/run
- **Idempotency key** â€” deterministic â€œsame input âœ same outputâ€ safety handle

---

## âœ… TL;DR

This folder proves that **KFMâ€™s provenance-first philosophy can extend cleanly into DevOps**:  
**code history becomes lineage**, and lineage stays queryable, enforceable, and UI-visible.
