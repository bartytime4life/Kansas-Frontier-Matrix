# â›“ï¸ PROV Schema (Provenance) â€” `mcp/dev_prov/policies/schemas/prov`

![Status](https://img.shields.io/badge/status-draft-yellow)
![Format](https://img.shields.io/badge/format-PROV--JSON%20%2B%20JSON--LD-blue)
![Standard](https://img.shields.io/badge/standard-W3C%20PROV--O-005A9C)
![Policy](https://img.shields.io/badge/policy-OPA%20%2B%20Conftest-7D3C98)
![Principles](https://img.shields.io/badge/principles-FAIR%20%2B%20CARE-2E86C1)

> ðŸ—ºï¸ **â€œThe map behind the map.â€**  
> Provenance is how KFM shows *where layers (and answers) came from* and *why you should trust them*.

---

## ðŸŽ¯ Purpose

This folder documents (and pairs with) the **PROV schema + profile expectations** used by the **MCP `dev_prov` policy pack** to validate provenance bundles across Kansas Frontier Matrix (KFM).

It is designed to support:

- **Data lineage** (raw âžœ processed âžœ published)
- **Dev provenance** (PRs / commits / CI runs âžœ artifacts)
- **AI provenance** (Focus Mode answers + citations âžœ traceable evidence)
- **Policy enforcement** (OPA/Conftest gates that fail-closed ðŸ”’)

---

## ðŸ§­ Where this fits

```text
ðŸ§  mcp/
  ðŸ§‘â€ðŸ’» dev_prov/
    ðŸ›¡ï¸ policies/
      ðŸ§© schemas/
        â›“ï¸ prov/
          ðŸ“„ README.md   ðŸ‘ˆ you are here
          (schema files live here too)
```

---

## ðŸ§© KFM â€œEvidence Bundleâ€ mindset

KFM treats publication as **evidence-first**. A publishable dataset (or layer) is not â€œrealâ€ until it is backed by a **bundle**:

- ðŸ›°ï¸ **STAC** â†’ geospatial assets + spatial/temporal metadata  
- ðŸ“¦ **DCAT** â†’ dataset-level catalog + governance metadata  
- â›“ï¸ **PROV** â†’ *lineage graph* explaining how it was produced

This README documents the **PROV side** of that bundle.

---

## ðŸ§  PROV mental model (fast refresh)

PROV describes history using three building blocks:

- **Entity** â†’ â€œa thingâ€ (file, dataset, layer, artifact, answer payload)
- **Activity** â†’ â€œa processâ€ (ingest, transform, validate, render, AI response)
- **Agent** â†’ â€œan actorâ€ (person, team, bot, CI runner, service)

â€¦and relationships:

- `prov:used` â†’ an Activity used an Entity
- `prov:wasGeneratedBy` â†’ an Entity was generated by an Activity
- `prov:wasAssociatedWith` â†’ an Activity is associated with an Agent

âœ… KFM uses **PROV-JSON style sections** (`entity`, `activity`, `agent`, â€¦) and anchors them with a **JSON-LD context** (so the same artifact can be graph-ingested cleanly).

---

## âœ… What KFM-PROV requires (Profile expectations)

> **Goal:** no â€œmystery layers,â€ no â€œtrust me bro,â€ no untraceable AI answers.

### 1) Required top-level structure

A KFM PROV bundle SHOULD include:

- `@context` (JSON-LD context)
- `entity` object (map of entity IDs â†’ entity attributes)
- `activity` object (map of activity IDs â†’ activity attributes)
- `agent` object (map of agent IDs â†’ agent attributes)
- relationship blocks (at least `used`, `wasGeneratedBy`, `wasAssociatedWith`)

### 2) Minimum viable provenance chain

For every **published output entity** (processed dataset / layer / artifact / answer):

- There MUST be an Activity that generated it (`wasGeneratedBy`)
- That Activity MUST reference at least one input (`used`)
- That Activity MUST be attributable to an Agent (`wasAssociatedWith`)
- The bundle SHOULD include timestamps (start/end or at least start)

### 3) Reproducibility fields (KFM extensions)

KFM extends standard PROV so the graph answers real questions like:

- â€œWhich pipeline run produced this?â€
- â€œWhich commit/container built this artifact?â€
- â€œWhich source datasets were used, and with what parameters?â€

Recommended KFM extension fields (names are illustrative; keep the actual profile authoritative):

- `kfm:run_id` / `kfm:run_ref` (stable run identity)
- `kfm:pipeline` / `kfm:pipeline_version` (script path, container digest, or tag)
- `kfm:parameters` (safe, non-secret parameters)
- `kfm:checksums` (sha256, etag, or content hash for key inputs/outputs)
- `kfm:catalog_refs` (pointers to STAC/DCAT entries that describe the entity)
- `kfm:policy_decisions` (optional: rule IDs + pass/fail summaries)

### 4) Cross-linking to STAC/DCAT (no loose ends)

A PROV bundle SHOULD be linkable *from* the catalog entries, and should link back:

- **STAC** should point to provenance (commonly via an asset/link)
- **DCAT** should point to provenance (as distribution/landingPage-related metadata)
- **PROV** should include references that allow reverse-navigation back to STAC/DCAT IDs

Think: bidirectional graph edges ðŸ”

---

## ðŸ›¡ï¸ Policy Pack expectations (OPA / Conftest)

This schema is here because KFMâ€™s governance model is **policy-as-code**.

Typical enforcement points:

- âœ… On PR / CI: schema validation + required files present
- âœ… On ingestion/publishing: provenance required for promotion
- âœ… On AI responses: citations must resolve to catalog/provenance-backed sources
- ðŸš« Fail-closed: missing lineage or missing citations = no publish / no merge

### Example rule patterns

- `KFM-PROV-001` â€” processed data changed without matching PROV update
- â€œProvenance-first publishingâ€ â€” refuse promotion if provenance is missing
- â€œEvidence-first answersâ€ â€” refuse Focus Mode responses without resolvable citations

> ðŸ§¯ Exceptions (if allowed) should be **time-bound** and tracked (e.g., via a `waivers.yml` pattern), never informal.

---

## ðŸ§‘â€ðŸ’» Dev provenance (GitHub â†’ PROV graph)

KFM also wants provenance for the *software side*:

- PRs become **Activities**
- Commits / build artifacts become **Entities**
- Authors, reviewers, CI bots become **Agents**
- Merge artifacts are generated by Activities that used the commit Entities
- CI validation emits lineage-friendly events (OpenLineage-style) that can map into PROV

This enables audit queries like:

- â€œWhich PR introduced the pipeline that produced this dataset?â€
- â€œWhich reviewer approved the transformation step?â€
- â€œWhich CI run signed the artifact?â€

---

## ðŸ—ºï¸ UI & Focus Mode integration

Provenance is not just for backend governanceâ€”itâ€™s part of the user experience:

- ðŸ§¾ Layer Info should show **source, license, and how it was prepared**
- ðŸ§­ A provenance panel can display lineage (â€œmap behind the mapâ€)
- ðŸ¤– Focus Mode should present **answer + citations** that users can click through

When provenance exists and is enforced, UI becomes:

- easier to trust âœ…
- easier to debug ðŸ”
- easier to reproduce ðŸ§ª

---

## ðŸ” Security, privacy, and FAIR+CARE

Provenance is also a safety tool:

- Support **audit trails** (who accessed/derived what)
- Support **inference controls** (prevent re-identification / leakage patterns)
- Respect **Authority & Ethics** for sensitive or restricted datasets

If you record provenance, record it responsibly:

- ðŸš« Donâ€™t store secrets in provenance fields
- âœ… Do store checksums, identifiers, and safe parameter summaries
- âœ… Do link to governance docs and restrictions where relevant

---

## âœï¸ Authoring guide

### Step-by-step checklist (authoring a new PROV bundle)

1. Pick stable IDs for:
   - output entity (processed dataset / artifact)
   - activity (pipeline run)
   - input entities (sources)
   - agent (person/system)
2. Populate minimum fields:
   - labels
   - timestamps
   - `used` + `wasGeneratedBy` + `wasAssociatedWith`
3. Add reproducibility hooks:
   - pipeline version / container digest / commit SHA
   - key parameters (safe)
   - checksums for inputs/outputs
4. Cross-link:
   - include references to STAC/DCAT entries for the dataset
5. Run validation (CI locally if possible)

---

## ðŸ§ª Examples

> These are **illustrative** examples. Keep the **actual** profile + schema authoritative.

### Example A â€” minimal pipeline provenance (PROV-JSON + JSON-LD context)

```json
{
  "@context": "https://www.w3.org/ns/prov.jsonld",
  "entity": {
    "kfm:raw/source/usgs_streamflow_2026-01-22": {
      "prov:label": "USGS Streamflow snapshot (raw)",
      "prov:type": "kfm:RawDataset",
      "kfm:sha256": "â€¦"
    },
    "kfm:processed/datasets/river_gauges_v1": {
      "prov:label": "River gauge dataset (normalized)",
      "prov:type": "kfm:ProcessedDataset",
      "kfm:dataset_id": "water/river-gauges",
      "kfm:sha256": "â€¦"
    }
  },
  "activity": {
    "kfm:run/2026-01-22T12:34:56Z#ingest_river_gauges": {
      "prov:label": "Ingest + normalize river gauges",
      "prov:startTime": "2026-01-22T12:34:56Z",
      "prov:endTime": "2026-01-22T12:40:10Z",
      "kfm:pipeline": "pipelines/water/ingest_river_gauges.py",
      "kfm:pipeline_version": "git:abc1234",
      "kfm:run_id": "3e7d5b2c-3b8d-4c32-8b52-7c1e5c6f0a9b"
    }
  },
  "agent": {
    "kfm:agent/github-actions": {
      "prov:type": "prov:SoftwareAgent",
      "prov:label": "GitHub Actions (kfm-ci)"
    }
  },
  "used": {
    "_:u1": {
      "prov:activity": "kfm:run/2026-01-22T12:34:56Z#ingest_river_gauges",
      "prov:entity": "kfm:raw/source/usgs_streamflow_2026-01-22"
    }
  },
  "wasGeneratedBy": {
    "_:g1": {
      "prov:entity": "kfm:processed/datasets/river_gauges_v1",
      "prov:activity": "kfm:run/2026-01-22T12:34:56Z#ingest_river_gauges"
    }
  },
  "wasAssociatedWith": {
    "_:a1": {
      "prov:activity": "kfm:run/2026-01-22T12:34:56Z#ingest_river_gauges",
      "prov:agent": "kfm:agent/github-actions"
    }
  }
}
```

### Example B â€” GitHub PR provenance (Dev provenance)

```json
{
  "@context": "https://www.w3.org/ns/prov.jsonld",
  "entity": {
    "kfm:git/commit/abc1234": {
      "prov:label": "Commit abc1234",
      "prov:type": "kfm:GitCommit"
    },
    "kfm:artifact/container/kfm-ingest@sha256:deadbeefâ€¦": {
      "prov:label": "Ingest container image",
      "prov:type": "kfm:BuildArtifact",
      "kfm:digest": "sha256:deadbeefâ€¦"
    }
  },
  "activity": {
    "kfm:github/pr/742": {
      "prov:label": "PR #742 â€” Improve ingest provenance",
      "prov:startTime": "2026-01-20T18:10:00Z",
      "prov:endTime": "2026-01-21T02:44:00Z",
      "prov:type": "kfm:PullRequest"
    },
    "kfm:ci/run/982314": {
      "prov:label": "CI run #982314",
      "prov:startTime": "2026-01-21T02:10:00Z",
      "prov:type": "kfm:BuildAndTest"
    }
  },
  "agent": {
    "kfm:github/user/alex": {
      "prov:label": "alex (author)",
      "prov:type": "prov:Person"
    },
    "kfm:agent/github-actions": {
      "prov:label": "GitHub Actions",
      "prov:type": "prov:SoftwareAgent"
    }
  },
  "used": {
    "_:u1": { "prov:activity": "kfm:github/pr/742", "prov:entity": "kfm:git/commit/abc1234" },
    "_:u2": { "prov:activity": "kfm:ci/run/982314", "prov:entity": "kfm:git/commit/abc1234" }
  },
  "wasGeneratedBy": {
    "_:g1": { "prov:entity": "kfm:artifact/container/kfm-ingest@sha256:deadbeefâ€¦", "prov:activity": "kfm:ci/run/982314" }
  },
  "wasAssociatedWith": {
    "_:a1": { "prov:activity": "kfm:github/pr/742", "prov:agent": "kfm:github/user/alex" },
    "_:a2": { "prov:activity": "kfm:ci/run/982314", "prov:agent": "kfm:agent/github-actions" }
  }
}
```

---

## ðŸ§ª Validation

Validation normally happens in CI, but should also be runnable locally.

Common patterns:

- Validate PROV bundles with **JSON Schema**
- Gate merges with **Conftest** running **OPA/Rego** policies
- Ensure provenance cross-links resolve to STAC/DCAT IDs

> âœ… Tip: Keep fixtures/examples near the schema so PRs can prove behavior.

---

## ðŸ§¾ Versioning & compatibility

- The KFM standards set uses explicit **versioning** (e.g., `KFM-PROV v11.x`)
- Schema changes should be treated as:
  - âœ… additive when possible (non-breaking)
  - ðŸš¨ version-bumped when required (breaking changes)

Recommended discipline:

- Add a changelog entry for every schema/profile update
- Include migration notes for breaking changes
- Keep stable rule IDs (e.g., `KFM-PROV-001`) so waivers and dashboards donâ€™t break

---

## âœ… Definition of Done (DoD) for PROV changes

- [ ] Schema/profile update is documented (what + why)
- [ ] Examples/fixtures updated (or added)
- [ ] Policy tests updated (OPA/Conftest)
- [ ] Cross-links to STAC/DCAT still resolve
- [ ] No sensitive values were introduced into provenance payloads
- [ ] UI/consumer impact is noted if the shape changes

---

## ðŸ“š Project references (documents)

> Keep this list current; provenance work touches the entire stack.

- KFM Data Intake Guide (STAC/DCAT/PROV evidence bundle)
- KFM Architecture & Design (policy gates, provenance-first enforcement)
- KFM AI System Overview (auditability + governance ledger)
- KFM UI System Overview (user-visible provenance and citations)
- Additional Project Ideas (OCI artifacts + attaching PROV/cosign patterns)
- MCP / Master Coder Protocol docs (traceability + reproducibility discipline)
- Geospatial processing references (projection metadata, CRS hygiene)

---

## ðŸ§  Related schema folders (sibling concepts)

- ðŸ›°ï¸ `â€¦/schemas/stac/` â€” STAC Items/Collections profile
- ðŸ“¦ `â€¦/schemas/dcat/` â€” DCAT dataset profile
- ðŸ§¾ `â€¦/schemas/story/` â€” Story node evidence manifests (if present)
- ðŸ” `â€¦/schemas/security/` â€” classification / access control metadata (if present)

---

### â­ If you only remember one thingâ€¦

> **Provenance isnâ€™t paperwork** â€” itâ€™s how KFM becomes *auditable, reproducible, and trustworthy*.
