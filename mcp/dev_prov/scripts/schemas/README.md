# ğŸ§¬ `dev_prov` Schemas (Contractâ€‘First Provenance)

<p align="center">
  <kbd>ğŸ§¾ contract-first</kbd>
  <kbd>ğŸ§­ PROV / JSON-LD</kbd>
  <kbd>ğŸ§ª CI gates</kbd>
  <kbd>âš–ï¸ FAIR + CARE</kbd>
  <kbd>ğŸ”’ fail-closed</kbd>
</p>

> **TL;DR**: This folder is the **schema registry** for everything produced/consumed by `mcp/dev_prov` scripts â€” especially **DevOps â†’ PROV** records (PRs/commits/releases), **pipeline run manifests**, **agent action logs**, and **telemetry/energy artifacts**.  
> If an artifact can affect what KFM publishes, serves, or reasons over, it must be **validated against a schema** here.

---

## ğŸ¯ Why this folder exists

KFM is built around **metadata-as-code** and **provenance-first** operations:

- **No black boxes**: every dataset and every â€œimportant actionâ€ should be traceable (who/what/when/why/how).  
- **Contract-first**: schemas are the *source of truth* for what is allowed to enter the system.
- **Governance at the edges**: CI and policy gates validate artifacts before promotion (fail closed if uncertain).
- **Human + Agent parity**: scripts may generate changes, but they still must pass the same schema + policy checks.

This folder makes those guarantees enforceable.

---

## ğŸ—‚ï¸ What lives here

> Keep this list updated as schemas are added/renamed. Think of it as a **living index** ğŸ§ âœ¨

### âœ… Core schema families

| Family | What it validates | Why it matters | Typical producers/consumers |
|---|---|---|---|
| ğŸ§­ **PROV JSON-LD** | `prov:Entity / Activity / Agent` records | end-to-end lineage (data + devops + AI) | CI, ingestion pipelines, graph ingest |
| ğŸ§‘â€ğŸ’» **GitHub / DevOps PROV** | PRs, commits, merges, releases as PROV | â€œwhich PR produced this dataset & who reviewed it?â€ | CI hooks, Neo4j ingest |
| ğŸ§¾ **Run Manifests / Audits** | per-run ledgers (inputs/outputs/tools/errors/digests) | reproducibility + policy checks + idempotency | pipelines, audits, policy pack |
| ğŸ¤– **AgentAction** | planner/executor suggestions vs executed steps | transparency of AI assistance | W-P-E agents, provenance pipeline |
| ğŸ“¡ **Telemetry / Energy** | traces + energy/carbon summaries | operational accountability | CI runbooks, observability checks |
| ğŸ§· **Evidence / Narrative Inputs** *(optional)* | citation blocks, story evidence manifests | â€œevidence-first narrativeâ€ | Story tooling, Focus Mode publishing |

---

## ğŸ§± Recommended directory layout (flexible)

Even if your repo is currently flat, use this as a mental model. If you add subfolders, keep names predictable.

```text
ğŸ“ mcp/dev_prov/scripts/
  ğŸ“ schemas/ ğŸ§¬
    ğŸ“„ README.md
    ğŸ“ prov/         ğŸ§­  (PROV profiles / shapes)
    ğŸ“ github/       ğŸ§‘â€ğŸ’» (PR/commit/release provenance)
    ğŸ“ runs/         ğŸ§¾  (run manifests, audit ledgers)
    ğŸ“ agents/       ğŸ¤–  (AgentAction + automation traces)
    ğŸ“ telemetry/    ğŸ“¡  (OpenTelemetry + energy/carbon)
    ğŸ“ policy/       ğŸ§ª  (optional: policy input/report schemas)
```

> ğŸ’¡ If you keep a flat layout, prefix filenames: `prov__*`, `github__*`, `runs__*`, etc.

---

## ğŸ”— How these schemas plug into KFM

### 1) CI â€œDetect â†’ Validate â†’ Promoteâ€ ğŸ§ªâ¡ï¸âœ…â¡ï¸ğŸš€

A typical flow:

1. **Detect** changes (PR diff, new datasets, pipeline outputs, etc.)
2. **Validate**:
   - JSON/YAML formatting & linting
   - **Schema validation** (this folder âœ…)
   - Policy Pack checks (OPA/Conftest)
   - Link/reference integrity checks
3. **Promote** only if everything passes (merge/deploy/import)

### 2) Policy Pack integration âš–ï¸

Schemas and policy gates work together:

- Schemas ensure **structure** and required fields are present
- Policies ensure **rules** and invariants (license present, classification propagation, provenance required, etc.)

See:
- `../../../../api/scripts/policy/README.md`
- `../../../../tools/validation/policy/`

### 3) Graph ingest (Neo4j) ğŸ•¸ï¸

Validated PROV JSON-LD is ingested so that development history and data lineage become queryable.

Example queries unlocked:
- â€œWhich PR produced dataset `kfm.dataset.*` and who reviewed it?â€
- â€œList PRs that touched hydrology pipelines in the last year.â€
- â€œShow all pipeline runs that used a sensitive input and ensure output stayed â‰¥ that classification.â€

---

## ğŸ§­ PROV + JSON-LD conventions (KFM flavor)

### âœ… What we standardize here

**Represent development + pipelines using PROV:**

- **PR / Merge** â†’ `prov:Activity`
- **Commits / artifacts / configs** â†’ `prov:Entity`
- **Authors / reviewers / CI bot / agents** â†’ `prov:Agent`

Use PROV relations consistently:

- `prov:used` â€” Activity used an input Entity (commit, config, dataset, etc.)
- `prov:wasAssociatedWith` â€” Activity associated with Agent (human, bot, CI)
- `prov:wasGeneratedBy` â€” output Entity generated by Activity

### ğŸ”’ Minimum expectations

- Every record must be **self-identifying** (`@id`) and typed (`@type`)
- Records must be **linkable** to:
  - commits (SHA), PR number, repo, workflow run id
  - dataset ids / artifact digests (when relevant)
- Include **timestamps** in a consistent format (ISO 8601)
- Include **classification / care labels** when the record references governed data

> ğŸ”¥ If you add a new artifact type, define how it maps into: **Entity / Activity / Agent**.

---

## ğŸ§¾ Run manifests (audit ledgers)

Run manifests are â€œwhat happenedâ€ receipts:

- inputs (hashes, source URLs, dataset ids)
- outputs (artifacts, counts, digests)
- toolchain (versions)
- error summaries
- a canonical digest / idempotency key (so re-running the same exact operation yields the same identity)

**Schema tips for this family:**
- include a `canonical_digest` (computed after canonicalization)
- include `tool_versions` and `runtime_env` for reproducibility
- include `summary_counts` and `errors[]` for reviewability

---

## ğŸ¤– AgentAction records (Planner â†” Executor parity)

If an AI agent proposes transformation steps, we log:

- the proposed plan (structured JSON)
- the validated config actually executed
- any deviations
- the review context (PR link, approver, timestamps)

**Why?** Later we can answer: â€œWhat did the agent suggest vs what shipped?â€ â€” and enforce â€œno silent automation.â€

---

## ğŸ“¡ Telemetry + energy artifacts

Telemetry validation enables runbooks like:

- â€œEvery CI run emits trace spans with expected attributesâ€
- â€œEnergy/carbon reports exist for sustainability goalsâ€
- â€œMissing telemetry fails a health checkâ€

Schemas in this family should:
- validate required span attributes (commit SHA, pipeline name, run id)
- validate energy report fields (duration, joules/kWh, COâ‚‚ estimate, sampling methodology)

---

## ğŸ§ª Validation workflows

### Local (developer) validation âœ…

Use whatever validator the repo standardizes on (Node `ajv`, Python `jsonschema`, or repo scripts). Typical pattern:

```bash
# Example shape (adapt to your tooling):
# validate <instance> against <schema>
dev_prov validate --schema ./schemas/github/pr_prov.schema.json --input ./out/pr_123.prov.jsonld
```

### CI validation ğŸ§°

CI should:
- validate all changed artifacts that match known patterns (`data/prov/**`, `data/catalog/**`, `data/stac/**`, `data/audits/**`, etc.)
- fail closed if schema validation cannot run or inputs are ambiguous
- surface errors with stable IDs (ex: `KFM-PROV-001`, `KFM-CAT-001`, â€¦)

---

## ğŸ§· Example: PR â†’ PROV JSON-LD (minimal)

> This is an illustrative example. Real schemas may require more fields.

```json
{
  "@context": {
    "prov": "http://www.w3.org/ns/prov#",
    "kfm":  "https://kansasfrontiermatrix.example/ns#"
  },
  "@id": "kfm:devprov/pr/1234",
  "@type": "prov:Activity",
  "prov:startedAtTime": "2026-01-21T18:42:11Z",
  "prov:endedAtTime": "2026-01-21T19:02:37Z",
  "prov:used": [
    { "@id": "kfm:git/commit/abc123", "@type": "prov:Entity" }
  ],
  "prov:wasAssociatedWith": [
    { "@id": "kfm:agent/github_user/alice", "@type": "prov:Agent" },
    { "@id": "kfm:agent/ci/github_actions", "@type": "prov:Agent" }
  ],
  "kfm:repo": "Kansas-Frontier-Matrix",
  "kfm:pr_number": 1234,
  "kfm:classification": "public"
}
```

---

## ğŸ§© Authoring rules for schemas (please follow)

### âœ… JSON Schema standards

- Declare `$schema` (dialect) and stable `$id`
- Prefer **Draft 2020-12** unless the repo standard says otherwise
- Use `additionalProperties: false` for â€œcore objectsâ€ (tight contracts)
- Provide:
  - `title`, `description`
  - minimal `examples`
  - `required` fields for contract guarantees

### ğŸ·ï¸ Versioning

- **SemVer** for schema changes:
  - **MAJOR**: breaking changes (required fields changed, meaning changed)
  - **MINOR**: backward-compatible additions
  - **PATCH**: clarifications, typo fixes, non-semantic changes
- Keep `$id` stable per version (donâ€™t silently change meaning without version bump)

### ğŸ”’ Governance baked in

Where applicable, schemas should include:

- `license` or `rights` fields (for catalog artifacts)
- `classification` / sensitivity level fields (public/sensitive/confidential/etc.)
- `care_label` fields when sovereignty or ethics apply
- references to upstream artifacts (STAC/DCAT/PROV links)

---

## âœ… Definition of Done (DoD) for adding/changing schemas

- [ ] Schema file added/updated in this folder ğŸ§¬
- [ ] At least **one valid example** instance added (and validated) ğŸŸ¢
- [ ] At least **one invalid example** (negative test) added ğŸ§¯
- [ ] CI wired to validate the artifact(s) that use this schema ğŸ§ª
- [ ] Policy Pack updated if new invariants are needed âš–ï¸
- [ ] Graph ingest updated if new IDs/types/relations introduced ğŸ•¸ï¸
- [ ] README index updated (this file) ğŸ“
- [ ] Breaking changes include migration notes (and version bump) ğŸš§

---

## ğŸ§­ Related docs (repo-relative)

- `../../../../docs/MASTER_GUIDE_v13.md`
- `../../../../docs/standards/` *(KFM profiles for STAC / DCAT / PROV)*
- `../../../../api/scripts/policy/README.md`
- `../../../../tools/validation/policy/`

---

## ğŸ—ºï¸ Big picture (DevOps â†” Data lineage)

```mermaid
flowchart LR
  PR[ğŸ§‘â€ğŸ’» GitHub PR] -->|dev_prov scripts| PROV[ğŸ§­ PROV JSON-LD]
  RUN[ğŸ§¾ Pipeline Run Manifest] -->|links| PROV
  PROV -->|validated by schemas| CI[ğŸ§ª CI + Policy Gates]
  CI -->|promote| GRAPH[ğŸ•¸ï¸ Neo4j Graph]
  GRAPH --> UI[ğŸ—ºï¸ UI / Focus Mode]
  UI -->|must cite| EVID[ğŸ§· Evidence & Citations]
```

> If it canâ€™t be validated, it canâ€™t be promoted. âœ…
