<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <meta name="color-scheme" content="light dark"/>
  <title>Kansas-Frontier-Matrix — Geo Timeline Viewer</title>

  <!-- MapLibre GL -->
  <link rel="stylesheet" href="https://unpkg.com/maplibre-gl@3.7.0/dist/maplibre-gl.css"/>
  <script defer src="https://unpkg.com/maplibre-gl@3.7.0/dist/maplibre-gl.js"></script>

  <!-- App styles -->
  <link rel="icon" href="./assets/favicon.svg" type="image/svg+xml"/>
  <link rel="stylesheet" href="./style.css"/>

  <style>
    /* page-only polish */
    .brand { display:flex; align-items:center; gap:10px; font-weight:700; }
    .brand img { width:24px; height:24px; }
    .muted { color: var(--muted); font-size: 12px; }
    .layer-meta { font-size: 11px; color: var(--muted); }
    .header .actions { display:flex; gap:8px; flex-wrap:wrap; margin-top:8px; }
  </style>
</head>
<body>
  <!-- Map (full bleed) -->
  <div id="map" aria-label="Time-aware map of Kansas"></div>

  <!-- Sidebar -->
  <aside id="sidebar" class="kfm-sidebar" role="complementary" aria-label="Controls and layer list">
    <div class="header">
      <h2 id="app-title">Kansas-Frontier-Matrix</h2>
      <div class="sub" id="app-subtitle">Time-aware historical GIS for Kansas</div>
      <div class="actions">
        <button id="btn-reset" class="btn" type="button" title="Reset view">Reset view</button>
        <button id="btn-theme" class="btn" type="button" aria-pressed="false" aria-label="Toggle theme">Theme: Auto</button>
        <a class="btn" href="https://github.com/bartytime4life/Kansas-Frontier-Matrix" target="_blank" rel="noopener">GitHub</a>
      </div>
    </div>

    <!-- Time controls -->
    <section id="timebox" class="section" role="region" aria-label="Timeline filter">
      <div class="label">
        <strong>Timeline</strong>
        <span class="dim mono" id="time-range"></span>
      </div>
      <div class="mt-8" aria-live="polite">
        <input id="year" class="kfm-range--fill" type="range" min="1850" max="2025" step="1" value="1930" aria-label="Filter layers by year"/>
        <span id="year-label" class="mono">1930</span>
      </div>
      <div id="status" class="dim mt-8" role="status" aria-live="polite"></div>
    </section>

    <!-- Layer list -->
    <section id="layerbox" class="section" role="region" aria-label="Layer list">
      <details open>
        <summary>Layers</summary>
        <div id="layers"></div>
      </details>
    </section>

    <!-- Legend -->
    <section id="legendbox" class="section" role="region" aria-label="Legend">
      <details open>
        <summary>Legend</summary>
        <div id="legend"></div>
      </details>
    </section>
  </aside>

  <script>
  // -----------------------------------------------------------------------------
  // Kansas-Frontier-Matrix — Connected viewer
  // Loads ./config/app.config.json → ./config/viewer.json → ./config/layers.json → ./layers.json
  // Supports: raster (url/tiles), geojson (data/path), style|paint, time.start/end & timeProperty
  // Builds grouped layer list and legend; wires timeline to layer visibility.
  // -----------------------------------------------------------------------------
  (async function () {
    const $ = (sel, root=document) => root.querySelector(sel);
    const el = (tag, attrs={}, children=[]) => {
      const n = document.createElement(tag);
      for (const [k,v] of Object.entries(attrs)) {
        if (k === 'class') n.className = v;
        else if (k === 'style') n.setAttribute('style', v);
        else if (k.startsWith('on') && typeof v === 'function') n.addEventListener(k.slice(2), v);
        else n.setAttribute(k, v);
      }
      for (const ch of [].concat(children)) n.append(ch?.nodeType ? ch : document.createTextNode(ch));
      return n;
    };

    const statusEl = $('#status');
    const yearEl = $('#year');
    const yearLabelEl = $('#year-label');
    const timeRangeEl = $('#time-range');
    const layersWrap = $('#layers');
    const legendWrap = $('#legend');
    const btnReset = $('#btn-reset');
    const appTitle = $('#app-title');
    const appSubtitle = $('#app-subtitle');
    const btnTheme = $('#btn-theme');

    const setStatus = (msg) => { statusEl.textContent = msg || ''; };

    // Try config locations (preferred first)
    async function loadConfig() {
      const attempts = [
        './app.config.json',
        './config/app.config.json',
        './config/viewer.json',
        './config/layers.json',
        './layers.json'
      ];
      let lastErr;
      for (const url of attempts) {
        try {
          const r = await fetch(url, { cache: 'no-store' });
          if (!r.ok) throw new Error(`${url}: ${r.status}`);
          const j = await r.json();
          return { url, cfg: j };
        } catch (e) { lastErr = e; }
      }
      throw lastErr;
    }

    let cfg;
    try {
      const res = await loadConfig();
      cfg = res.cfg;
    } catch (e) {
      console.error(e);
      setStatus('Failed to load configuration (checked app.config.json, viewer.json, layers.json).');
      return;
    }

    // Merge time_config.json if present
    try {
      const tr = await fetch('./config/time_config.json', { cache: 'no-store' });
      if (tr.ok) {
        const tc = await tr.json();
        cfg.time = tc.time ?? cfg.time;
        if (typeof tc.defaultYear !== 'undefined') cfg.defaultYear = tc.defaultYear;
        if (tc.timeUI) cfg.timeUI = tc.timeUI;
      }
    } catch (_) { /* optional */ }

    // Titles
    if (cfg.title) appTitle.textContent = cfg.title;
    if (cfg.subtitle) appSubtitle.textContent = cfg.subtitle;

    // Map init
    const map = new maplibregl.Map({
      container: 'map',
      style: cfg.style || 'https://demotiles.maplibre.org/style.json',
      center: cfg.center || [-98.3, 38.5],
      zoom: cfg.zoom ?? 6,
      attributionControl: true
    });
    map.addControl(new maplibregl.NavigationControl({ visualizePitch: true }), 'top-right');
    map.addControl(new maplibregl.ScaleControl({ unit: 'imperial' }));

    const defaults = cfg.defaults || {};
    const layers = Array.isArray(cfg.layers) ? cfg.layers : [];

    // Time UI
    const tMin = (cfg.time && cfg.time.min) ? new Date(cfg.time.min) : new Date('1850-01-01');
    const tMax = (cfg.time && cfg.time.max) ? new Date(cfg.time.max) : new Date('2025-12-31');
    const defaultYear = cfg.defaultYear ?? 1930;
    const clampYear = (y) => Math.min(tMax.getUTCFullYear(), Math.max(tMin.getUTCFullYear(), y));

    // Slider wiring + filled track CSS var
    function setSliderValue(y) {
      yearEl.value = String(y);
      yearLabelEl.textContent = String(y);
      const min = parseInt(yearEl.min, 10), max = parseInt(yearEl.max, 10);
      const pct = ((y - min) / (max - min)) * 100;
      yearEl.style.setProperty('--value', pct + '%');
    }
    yearEl.min = String(tMin.getUTCFullYear());
    yearEl.max = String(tMax.getUTCFullYear());
    setSliderValue(clampYear(defaultYear));
    timeRangeEl.textContent = `(${tMin.toISOString().slice(0,10)} → ${tMax.toISOString().slice(0,10)})`;

    // Helper: tile URL list for rasters
    function tilesFrom(L) {
      if (Array.isArray(L.tiles) && L.tiles.length) return L.tiles;
      if (typeof L.url === 'string') return [L.url];
      if (typeof L.path === 'string') return [L.path];
      return null;
    }
    // Helper: geojson data URL
    function dataFrom(L) {
      return L.data || L.path || null;
    }
    // Normalize style/paint to a single object {line, fill, circle}
    function normalizePaint(L) {
      if (L.paint) return L.paint;
      const s = L.style || {};
      const out = {};
      if ('lineColor' in s || 'lineWidth' in s || 'lineOpacity' in s || 'lineDasharray' in s) {
        out.line = {
          'line-color': s.lineColor ?? '#000',
          'line-width': s.lineWidth ?? 1,
          'line-opacity': s.lineOpacity ?? 1,
          ...(s.lineDasharray ? { 'line-dasharray': s.lineDasharray } : {})
        };
      }
      if ('fillColor' in s || 'fillOpacity' in s || 'fillOutlineColor' in s) {
        out.fill = {
          'fill-color': s.fillColor ?? '#000',
          'fill-opacity': s.fillOpacity ?? 0.4,
          ...(s.fillOutlineColor ? { 'fill-outline-color': s.fillOutlineColor } : {})
        };
      }
      if ('circleColor' in s || 'circleRadius' in s || 'circleOpacity' in s || 'circleStrokeColor' in s || 'circleStrokeWidth' in s) {
        out.circle = {
          'circle-color': s.circleColor ?? '#000',
          'circle-radius': s.circleRadius ?? 3,
          'circle-opacity': s.circleOpacity ?? 1,
          ...(s.circleStrokeColor ? { 'circle-stroke-color': s.circleStrokeColor } : {}),
          ...(s.circleStrokeWidth ? { 'circle-stroke-width': s.circleStrokeWidth } : {})
        };
      }
      return out;
    }
    // Time window for layer
    function getTimeWindow(L) {
      const t = L.time || {};
      const s = t.start ? new Date(t.start).getUTCFullYear() : -Infinity;
      const e = t.end ? new Date(t.end).getUTCFullYear() : Infinity;
      return [s, e];
    }
    function visibleForYear(L, y) {
      const [s,e] = getTimeWindow(L);
      return s <= y && y <= e;
    }

    // Adders
    function addRaster(L) {
      const id = L.id;
      const tiles = tilesFrom(L);
      if (!tiles) { console.warn('Raster missing url/tiles:', L); return; }
      if (!map.getSource(id)) {
        map.addSource(id, {
          type: 'raster',
          tiles,
          tileSize: L.tileSize || defaults.tileSize || 256,
          attribution: L.attribution || undefined,
          crossOrigin: 'anonymous'
        });
      }
      if (!map.getLayer(id)) {
        map.addLayer({
          id, type: 'raster', source: id,
          paint: { 'raster-opacity': (typeof L.opacity === 'number') ? L.opacity : (defaults.opacity ?? 1.0) },
          layout: { visibility: (L.visible ?? defaults.visible ?? true) ? 'visible' : 'none' }
        });
      }
    }

    async function addGeoJSON(L) {
      const id = L.id;
      const data = dataFrom(L);
      if (!data) { console.warn('GeoJSON missing data/path:', L); return; }

      if (!map.getSource(id)) {
        map.addSource(id, { type: 'geojson', data, attribution: L.attribution || undefined });
      }
      const paint = normalizePaint(L);

      if (paint.line && !map.getLayer(id + '-line')) {
        map.addLayer({
          id: id + '-line',
          type: 'line',
          source: id,
          paint: {
            'line-color': paint.line['line-color'],
            'line-width': paint.line['line-width'],
            'line-opacity': paint.line['line-opacity'],
            ...(paint.line['line-dasharray'] ? { 'line-dasharray': paint.line['line-dasharray'] } : {})
          },
          layout: { visibility: (L.visible ?? true) ? 'visible' : 'none' }
        });
      }
      if (paint.fill && !map.getLayer(id + '-fill')) {
        map.addLayer({
          id: id + '-fill',
          type: 'fill',
          source: id,
          paint: {
            'fill-color': paint.fill['fill-color'],
            'fill-opacity': (paint.fill['fill-opacity'] ?? 0.4) * (typeof L.opacity === 'number' ? L.opacity : 1),
            ...(paint.fill['fill-outline-color'] ? { 'fill-outline-color': paint.fill['fill-outline-color'] } : {})
          },
          layout: { visibility: (L.visible ?? true) ? 'visible' : 'none' }
        });
      }
      if (paint.circle && !map.getLayer(id + '-circle')) {
        map.addLayer({
          id: id + '-circle',
          type: 'circle',
          source: id,
          paint: {
            'circle-color': paint.circle['circle-color'],
            'circle-radius': paint.circle['circle-radius'],
            'circle-opacity': (paint.circle['circle-opacity'] ?? 1) * (typeof L.opacity === 'number' ? L.opacity : 1),
            ...(paint.circle['circle-stroke-color'] ? { 'circle-stroke-color': paint.circle['circle-stroke-color'] } : {}),
            ...(paint.circle['circle-stroke-width'] ? { 'circle-stroke-width': paint.circle['circle-stroke-width'] } : {})
          },
          layout: { visibility: (L.visible ?? true) ? 'visible' : 'none' }
        });
      }
    }

    async function ensureLayer(L) {
      if (!L || !L.id || !L.type) return;
      if (L.type === 'raster' || L.type === 'image') addRaster(L);
      else if (L.type === 'geojson') await addGeoJSON(L);
    }

    // UI builders
    function makeLayerRow(L) {
      const row = el('div', { class: 'layer', 'data-layer-id': L.id });

      // Toggle (switch)
      const switchEl = el('button', {
        class: 'switch',
        role: 'switch',
        'aria-checked': (L.visible ?? true) ? 'true' : 'false',
        'aria-label': `Toggle ${L.title || L.id}`
      }, [el('span', { class: 'switch__dot' })]);
      switchEl.addEventListener('click', () => {
        const now = switchEl.getAttribute('aria-checked') === 'true';
        const next = !now;
        switchEl.setAttribute('aria-checked', next ? 'true' : 'false');
        const ids = (L.type === 'geojson')
          ? [L.id + '-line', L.id + '-fill', L.id + '-circle']
          : [L.id];
        const vis = next ? 'visible' : 'none';
        ids.forEach(x => map.getLayer(x) && map.setLayoutProperty(x, 'visibility', vis));
      });

      const name = el('div', { class: 'layer__name' }, L.title || L.id);

      // Opacity slider
      const op = el('input', {
        type: 'range', min: '0', max: '1', step: '0.01',
        value: String(L.opacity ?? 1), class: 'input--opacity',
        'aria-label': `Opacity ${L.title || L.id}`
      });
      op.addEventListener('input', () => {
        const v = parseFloat(op.value);
        if (L.type === 'geojson') {
          const paint = normalizePaint(L);
          if (map.getLayer(L.id + '-fill'))   map.setPaintProperty(L.id + '-fill',   'fill-opacity',   (paint.fill?.['fill-opacity'] ?? 0.4) * v);
          if (map.getLayer(L.id + '-line'))   map.setPaintProperty(L.id + '-line',   'line-opacity',   (paint.line?.['line-opacity'] ?? 1)     * v);
          if (map.getLayer(L.id + '-circle')) map.setPaintProperty(L.id + '-circle', 'circle-opacity', (paint.circle?.['circle-opacity'] ?? 1) * v);
        } else if (map.getLayer(L.id)) {
          map.setPaintProperty(L.id, 'raster-opacity', v);
        }
      });

      const right = el('div', { class: 'layer__controls' }, [switchEl, op]);
      row.append(name, right);
      return row;
    }

    function addLegendFor(L) {
      if (!Array.isArray(L.legend) || !L.legend.length) return;
      for (const item of L.legend) {
        const sw = el('span', { class: 'legend__swatch', style: `background:${item.color || '#999'}` });
        const name = el('span', { class: 'legend__name' }, item.label || L.title || L.id);
        const row = el('div', { class: 'legend__row' }, [sw, name]);
        legendWrap.append(row);
      }
    }

    function buildLayerList() {
      layersWrap.textContent = '';
      const order = Array.isArray(cfg.groups) ? cfg.groups : [];
      const groups = new Map();
      for (const L of layers) {
        const g = L.group || 'Ungrouped';
        if (!groups.has(g)) groups.set(g, []);
        groups.get(g).push(L);
      }
      const keys = [...order.filter(g => groups.has(g)), ...[...groups.keys()].filter(g => !order.includes(g))];
      for (const g of keys) {
        const list = groups.get(g);
        const det = el('details', { open: true });
        det.append(el('summary', {}, g));
        list.forEach(L => det.append(makeLayerRow(L)));
        layersWrap.append(det);
      }
    }

    async function addAllLayers() {
      for (const L of layers) {
        await ensureLayer(L);
        addLegendFor(L);
      }
    }

    function updateVisibilityForYear(y) {
      setSliderValue(y);
      let shown = 0, total = 0;

      for (const L of layers) {
        total++;
        const v = visibleForYear(L, y);
        const ids = (L.type === 'geojson') ? [L.id + '-line', L.id + '-fill', L.id + '-circle'] : [L.id];
        ids.forEach(x => map.getLayer(x) && map.setLayoutProperty(x, 'visibility', v && (L.visible ?? true) ? 'visible' : 'none'));
        if (v && (L.visible ?? true)) shown++;
      }
      setStatus(`${shown}/${total} layers visible for ${y}`);
    }

    // Events
    yearEl.addEventListener('input', () => updateVisibilityForYear(parseInt(yearEl.value, 10)));
    btnReset?.addEventListener('click', () => {
      const ctr = cfg.center || [-98.3, 38.5];
      const zm = cfg.zoom ?? 6;
      map.easeTo({ center: ctr, zoom: zm, pitch: 0, bearing: 0, duration: 600 });
    });

    // Map load bootstrap
    map.on('load', async () => {
      try {
        await addAllLayers();
        buildLayerList();
        updateVisibilityForYear(clampYear(defaultYear));
      } catch (e) {
        console.error(e);
        setStatus('Error initializing layers — check console for details.');
      }
    });

    // ---------------- Theme toggle (Auto → Light → Dark) ----------------
    (function themeToggle() {
      const STORAGE_KEY = "kfm-theme";  // "auto" | "light" | "dark"
      const CLASS_LIGHT = "kfm-theme-light";
      const CLASS_DARK  = "kfm-theme-dark";
      const root = document.documentElement;

      function current() {
        const saved = localStorage.getItem(STORAGE_KEY);
        return (saved === "light" || saved === "dark" || saved === "auto") ? saved : "auto";
      }
      function labelFor(mode) { return `Theme: ${mode[0].toUpperCase()}${mode.slice(1)}`; }
      function apply(mode) {
        root.classList.remove(CLASS_LIGHT, CLASS_DARK);
        if (mode === "light") {
          root.classList.add(CLASS_LIGHT);
          btnTheme?.setAttribute("aria-pressed", "true");
        } else if (mode === "dark") {
          root.classList.add(CLASS_DARK);
          btnTheme?.setAttribute("aria-pressed", "true");
        } else {
          btnTheme?.setAttribute("aria-pressed", "false");
        }
        if (btnTheme) btnTheme.textContent = labelFor(mode);
      }
      function next(mode) { return mode === "auto" ? "light" : mode === "light" ? "dark" : "auto"; }

      const media = window.matchMedia("(prefers-color-scheme: dark)");
      if (typeof media.addEventListener === 'function') {
        media.addEventListener("change", () => { if (current() === "auto") apply("auto"); });
      } else if (typeof media.addListener === 'function') {
        media.addListener(() => { if (current() === "auto") apply("auto"); });
      }

      apply(current());

      btnTheme?.addEventListener("click", () => {
        const mode = next(current());
        localStorage.setItem(STORAGE_KEY, mode);
        apply(mode);
      });
      btnTheme?.addEventListener("keydown", (e) => {
        if (e.key === " " || e.key === "Enter") { e.preventDefault(); btnTheme.click(); }
      });
      if (btnTheme) btnTheme.title = "Toggle theme (Auto → Light → Dark)";
    })();

  })();
  </script>
</body>
</html>
