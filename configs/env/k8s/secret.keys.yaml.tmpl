# TEMPLATE: Render this file into a real Secret manifest (e.g., secret.keys.yaml) and
# DO NOT COMMIT the rendered output.
#
# Suggested render workflow (envsubst):
#   export KFM_NAMESPACE=kfm
#   export KFM_JWT_SIGNING_KEY="$(openssl rand -base64 48)"
#   export KFM_ENCRYPTION_KEY="$(openssl rand -base64 48)"
#   export KFM_SESSION_SECRET="$(openssl rand -base64 48)"
#   envsubst < configs/env/k8s/secret.keys.yaml.tmpl > configs/env/k8s/secret.keys.yaml
#
# Apply:
#   kubectl apply -f configs/env/k8s/secret.keys.yaml
#
# NOTE: This template uses `stringData` so you can keep values un-base64'd; Kubernetes
# will store them as base64 in `.data` after apply.

apiVersion: v1
kind: Secret
metadata:
  name: kfm-secret-keys
  namespace: "${KFM_NAMESPACE}"
  labels:
    app.kubernetes.io/name: kfm
    app.kubernetes.io/part-of: kansas-frontier-matrix
type: Opaque
stringData:
  # --- Cryptographic keys (required) ---
  # Used to sign/verify JWTs (or equivalent auth tokens).
  KFM_JWT_SIGNING_KEY: "${KFM_JWT_SIGNING_KEY}"

  # Used for app-level encryption (envelope encryption, token encryption, etc.).
  KFM_ENCRYPTION_KEY: "${KFM_ENCRYPTION_KEY}"

  # Used to sign cookies / sessions (if applicable).
  KFM_SESSION_SECRET: "${KFM_SESSION_SECRET}"

  # --- Optional integrations (leave blank if unused) ---
  # Webhook verification / HMAC signing secret.
  KFM_WEBHOOK_SIGNING_SECRET: "${KFM_WEBHOOK_SIGNING_SECRET}"

  # Map tiles/geocoding provider token (if the frontend/server needs one).
  KFM_MAPS_PROVIDER_TOKEN: "${KFM_MAPS_PROVIDER_TOKEN}"

  # --- Repo-specific secrets ---
  # Add/rename keys to match the actual services deployed in your cluster.
  # Examples (uncomment if your stack uses them):
  # POSTGRES_PASSWORD: "${POSTGRES_PASSWORD}"
  # NEO4J_PASSWORD: "${NEO4J_PASSWORD}"
  # REDIS_PASSWORD: "${REDIS_PASSWORD}"
  # S3_SECRET_ACCESS_KEY: "${S3_SECRET_ACCESS_KEY}"
