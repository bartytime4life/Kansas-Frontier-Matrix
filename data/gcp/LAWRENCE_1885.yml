# Historical map georeferencing config — LAWRENCE (1885)
# Compatible with GDAL GCP-based warps and your ingest scripts.

id: LAWRENCE_1885
version: 1.2.0   # bump: safer helpers, optional working CRS, clearer outputs

image:
  path: data/raw/ut_pcl/LAWRENCE_1885.jpg
  width: null            # optional; QA only if known
  height: null           # optional; QA only if known
  dpi: null              # optional (e.g., 600)
  bands: 3               # RGB scan (adjust if different)
  color_profile: sRGB    # or unknown

# Reprojection strategy:
# - For simple/fast: warp directly to EPSG:4326 (good for KML SuperOverlays).
# - For best local fit: warp in projected working CRS (UTM 14N), THEN reproject to EPSG:4326.
target_crs: EPSG:4326       # final web/KML overlay CRS
working_crs: EPSG:26914     # optional; if null, skip 2–stage warp
source_crs: null            # if known (e.g., US Polyconic), record here for provenance

# Ground control points (pixel coords in source image; lon/lat in target_crs by default)
# Tip: ≥8 well-distributed GCPs (corners/edges/intersections). Keep outliers out.
gcps:
  - { px: 1234, py: 5678, lon: -95.235000, lat: 38.971000 }
  - { px: 2234, py: 5678, lon: -95.210000, lat: 38.960000 }
  - { px: 1834, py: 6678, lon: -95.220000, lat: 38.940000 }
  - { px: 1534, py: 4678, lon: -95.250000, lat: 38.955000 }

# Optional collar/neatline mask (in target CRS unless you set working_crs and mask in that CRS)
cutline:
  use_neatline: false
  neatline_geojson: data/gcp/LAWRENCE_1885_neatline.geojson
  neatline_wkt: null

warp:
  method: tps                # tps | poly1 | poly2 | poly3
  order: null                # ignored for tps; set 1/2/3 for poly
  resampling: cubic          # nearest|bilinear|cubic|lanczos
  dstalpha: true             # create alpha for collar/no-data
  error_threshold: 0.0       # 0 = exact transformer
  nodata: null               # e.g., 0 if pre-masked
  multithread: true          # allow multi-threaded gdalwarp
  overview_resampling: AVERAGE

  # Pixel alignment / resolution (optional). Usually let GDAL choose for scans.
  target_resolution: null    # meters (if working_crs) or degrees (if target_crs)
  target_extent: null        # [minx, miny, maxx, maxy] in final CRS (optional)

output:
  # If working_crs is set, the pipeline may create an intermediate _utm.tif before WGS84
  warped_tif:   data/work/georef/LAWRENCE_1885_wgs84.tif
  cog_tif:      data/cogs/overlays/usgs_topo_lawrence_1885.tif
  preview_png:  data/cogs/overlays/usgs_topo_lawrence_1885_preview.png
  build_cog:    true
  cog_profile:
    compress: JPEG           # JPEG for RGB scans
    quality: 85
    photometric: YCBCR
    blocksize: 512
    threads: ALL_CPUS
    bigtiff: IF_SAFER
    overview_resampling: AVERAGE

# Optional STAC hooks (your pipeline can mint/update these)
stac:
  collection_id: overlays
  item_id: lawrence_1885
  item_path: data/stac/items/overlays/lawrence_1885.json
  asset_key: cog
  asset_href: data/cogs/overlays/usgs_topo_lawrence_1885.tif

# Checksums your pipeline fills after build (provenance & CI)
checksums:
  source_sha256: null     # of data/raw/ut_pcl/LAWRENCE_1885.jpg
  warped_sha256: null
  cog_sha256: null

qa:
  rmse_pixels: null          # fill after warp if you compute residuals
  rmse_geounits: null        # meters or degrees depending on CRS
  gcps_used: auto            # auto | integer count
  notes: "Add ≥4 more GCPs near corners/edges for best results. Inspect residuals."

provenance:
  provider: "USGS / UT PCL (University of Texas Perry-Castañeda Library)"
  collection: "Historical Topographic Map"
  sheet: "LAWRENCE (1885)"
  license: "Public Domain (USGS)"
  links:
    source: null

# ---------------------------------------------------------------------------
# Helper commands (documentation; your scripts should read this YAML safely)
# Requires: python (stdlib), gdal (gdal_translate, gdalwarp), optional yq
# ---------------------------------------------------------------------------
gdal:
  # Emit -gcp args from YAML robustly (no awk/greps); assumes gcps are lon/lat in target_crs.
  add_gcps: >
    python - <<'PY'
    import sys, yaml, shlex
    d = yaml.safe_load(open('data/gcp/LAWRENCE_1885.yml', 'r'))
    src = d['image']['path']
    out = '/tmp/LAWRENCE_1885_gcps.tif'
    a_srs = (d.get('target_crs') or 'EPSG:4326')
    gcps = d.get('gcps', [])
    args = ['gdal_translate', '-of', 'GTiff', '-a_srs', a_srs]
    for p in gcps:
        args += ['-gcp', str(p['px']), str(p['py']), str(p['lon']), str(p['lat'])]
    args += [src, out]
    print(' '.join(shlex.quote(a) for a in args))
    PY
    | bash

  # One-stage warp (direct to target_crs); respects cutline if enabled.
  warp_tps: >
    python - <<'PY'
    import yaml, shlex
    d = yaml.safe_load(open('data/gcp/LAWRENCE_1885.yml','r'))
    dst = d['output']['warped_tif']
    cut = d['cutline']
    t_srs = d.get('target_crs','EPSG:4326')
    use_cut = bool(cut and cut.get('use_neatline'))
    cmd = ['gdalwarp', '-t_srs', t_srs, '-r', d['warp']['resampling'],
           '-dstalpha', '-et', str(d['warp']['error_threshold']),
           '-multi', '-wo', 'NUM_THREADS=ALL_CPUS']
    if d['warp']['method'] == 'tps':
        cmd.append('-tps')
    elif d['warp']['method'].startswith('poly'):
        order = d['warp'].get('order') or 2
        cmd += ['-order', str(order)]
    if use_cut:
        cmd += ['-cutline', cut['neatline_geojson'], '-crop_to_cutline']
    cmd += ['/tmp/LAWRENCE_1885_gcps.tif', dst]
    print(' '.join(shlex.quote(a) for a in cmd))
    PY
    | bash

  # Optional 2-stage: warp into working_crs for fit, then reproject to target_crs.
  warp_two_stage: >
    python - <<'PY'
    import os, yaml, shlex
    d = yaml.safe_load(open('data/gcp/LAWRENCE_1885.yml','r'))
    wcrs = d.get('working_crs')
    if not wcrs:
        raise SystemExit(0)
    cut = d['cutline']; use_cut = bool(cut and cut.get('use_neatline'))
    inter = 'data/work/georef/LAWRENCE_1885_utm.tif'
    dst = d['output']['warped_tif']
    # Stage 1: GCP warp to working CRS
    cmd1 = ['gdalwarp', '-t_srs', wcrs, '-r', d['warp']['resampling'], '-dstalpha', '-et', str(d['warp']['error_threshold']),
            '-multi', '-wo', 'NUM_THREADS=ALL_CPUS']
    if d['warp']['method'] == 'tps':
        cmd1.append('-tps')
    else:
        order = d['warp'].get('order') or 2
        cmd1 += ['-order', str(order)]
    if use_cut:
        cmd1 += ['-cutline', cut['neatline_geojson'], '-crop_to_cutline']
    cmd1 += ['/tmp/LAWRENCE_1885_gcps.tif', inter]
    # Stage 2: reproject to target CRS (web)
    t_srs = d.get('target_crs','EPSG:4326')
    cmd2 = ['gdalwarp', '-t_srs', t_srs, '-r', d['warp']['resampling'], '-dstalpha',
            '-multi', '-wo', 'NUM_THREADS=ALL_CPUS', inter, dst]
    print(' && '.join(' '.join(shlex.quote(a) for a in c) for c in (cmd1, cmd2)))
    PY
    | bash

  to_cog: >
    gdal_translate -of COG
    -co COMPRESS=JPEG -co QUALITY=85 -co PHOTOMETRIC=YCBCR
    -co BLOCKSIZE=512 -co NUM_THREADS=ALL_CPUS -co BIGTIFF=IF_SAFER
    -co OVERVIEW_RESAMPLING=AVERAGE
    "data/work/georef/LAWRENCE_1885_wgs84.tif" "data/cogs/overlays/usgs_topo_lawrence_1885.tif"

  preview_png: >
    gdal_translate -of PNG -outsize 25% 25%
    "data/work/georef/LAWRENCE_1885_wgs84.tif" "data/cogs/overlays/usgs_topo_lawrence_1885_preview.png"

# Optional convenience: where this sheet shows up in Earth/KML (documentation)
kml:
  networklink_href: data/earth/networklinks/usgs_topo_1894.kml   # sibling example; adapt when you add LAWRENCE
  kmz_output: data/kml/usgs_topo_lawrence_1885.kmz               # if you regionate this sheet as SuperOverlay