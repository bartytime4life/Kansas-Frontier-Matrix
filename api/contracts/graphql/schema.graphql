# ‚úÖ `api/contracts/graphql/schema.graphql` (KFM v13 Contract) üåæüó∫Ô∏è

![GraphQL](https://img.shields.io/badge/GraphQL-SDL-E10098?logo=graphql&logoColor=white)
![Contract-First](https://img.shields.io/badge/Contract--First-Yes-2ea44f)
![Provenance-First](https://img.shields.io/badge/Provenance--First-STAC%20%2B%20DCAT%20%2B%20PROV-blue)

> üìå **Purpose:** GraphQL contract that mirrors KFM‚Äôs **knowledge graph** (Person / Place / Event / Dataset / Document), supports **Story Nodes** and **Focus Mode**, and links strongly to **STAC / DCAT / PROV** for provenance-first discovery & transparency.

---

## üìÅ File placement

```text
api/
  contracts/
    graphql/
      schema.graphql   ‚úÖ
```

---

## üß¨ GraphQL SDL

```graphql
"""
Kansas Frontier Matrix (KFM) ‚Äî GraphQL Contract (v13)

Design goals:
- Mirror the Knowledge Graph structure (Person / Place / Event / Dataset / Document) for flexible traversal.
- Provenance-first: link to STAC / DCAT / PROV artifacts instead of duplicating facts.
- Story Nodes: narrative + map state configs.
- Focus Mode: opt-in AI summaries that must cite evidence and respect sensitivity/redaction policies.
"""

# ------------------------------------------------------------------------------
# Scalars
# ------------------------------------------------------------------------------

scalar Cursor
scalar Date
scalar DateTime
scalar URL
scalar JSON
scalar GeoJSON

# ------------------------------------------------------------------------------
# Directives (runtime-enforced by server; included here to keep contracts explicit)
# ------------------------------------------------------------------------------

"""
Role-based access control for fields/types.
"""
directive @auth(requires: [Role!] = [PUBLIC]) on OBJECT | FIELD_DEFINITION

"""
Marks a field/type as potentially sensitive; clients should not assume full precision.
Server must enforce redaction and access rules.
"""
directive @sensitive(level: SensitivityLevel! = SENSITIVE) on OBJECT | FIELD_DEFINITION

"""
Advisory cost hint for query planners / rate limiters.
"""
directive @cost(weight: Int! = 1) on FIELD_DEFINITION

# ------------------------------------------------------------------------------
# Root schema
# ------------------------------------------------------------------------------

schema {
  query: Query
  mutation: Mutation
}

# ------------------------------------------------------------------------------
# Enums
# ------------------------------------------------------------------------------

enum Role {
  PUBLIC
  CONTRIBUTOR
  REVIEWER
  ADMIN
  SYSTEM
}

enum SensitivityLevel {
  PUBLIC
  INTERNAL
  RESTRICTED
  SENSITIVE
}

enum RedactionMethod {
  NONE
  GENERALIZE
  OMIT
  BLUR
  AGGREGATE
  MASK_FIELDS
}

enum SortOrder {
  ASC
  DESC
}

enum RelationshipDirection {
  OUT
  IN
  BOTH
}

enum GraphEntityType {
  PERSON
  PLACE
  EVENT
  DOCUMENT
  DATASET
  ORGANIZATION
  TOPIC
  MEDIA_ASSET
}

enum DatasetKind {
  VECTOR
  RASTER
  TABLE
  DOCUMENT
  MODEL
  NOTEBOOK
  TILESET_3D
  OTHER
}

enum MapLayerType {
  VECTOR
  RASTER
  TERRAIN
  HILLSHADE
  MODEL_3D
}

enum MapSourceType {
  GEOJSON
  VECTOR_TILE
  RASTER_TILE
  TILEJSON
  WMS
  WMTS
  OGC_API_FEATURES
  CESIUM_3D_TILES
  OTHER
}

enum StoryStatus {
  DRAFT
  REVIEW
  PUBLISHED
  ARCHIVED
}

enum FocusAnswerStatus {
  ANSWERED
  INSUFFICIENT_EVIDENCE
  POLICY_RESTRICTED
}

enum JobStatus {
  QUEUED
  RUNNING
  SUCCEEDED
  FAILED
  CANCELLED
}

enum TimeStepUnit {
  YEAR
  MONTH
  DAY
  HOUR
}

enum TimeseriesAggregation {
  MEAN
  SUM
  MIN
  MAX
  COUNT
  MEDIAN
  PERCENTILE
}

enum FederationMode {
  LOCAL
  ONLY_REMOTE
  LOCAL_AND_REMOTE
}

# ------------------------------------------------------------------------------
# Common primitives
# ------------------------------------------------------------------------------

"""
Global node interface (Relay-ish).
"""
interface Node {
  id: ID!
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: Cursor
  endCursor: Cursor
}

type Link {
  rel: String!
  href: URL!
  type: String
  title: String
  hreflang: String
}

type ExternalIdentifier {
  scheme: String!
  identifier: String!
  url: URL
}

type Attribution {
  name: String!
  url: URL
  role: String
}

type ContactPoint {
  name: String
  email: String
  url: URL
}

type Point {
  lon: Float!
  lat: Float!
}

type BBox {
  west: Float!
  south: Float!
  east: Float!
  north: Float!
}

input BBoxInput {
  west: Float!
  south: Float!
  east: Float!
  north: Float!
}

type TimeRange {
  start: DateTime
  end: DateTime
}

input TimeRangeInput {
  start: DateTime
  end: DateTime
}

type SpatialExtent {
  bbox: BBox
  centroid: Point
  geometry: GeoJSON @sensitive(level: SENSITIVE)
}

"""
Explains what was generalized/removed and why.
"""
type RedactionPolicy {
  applied: Boolean!
  method: RedactionMethod!
  precisionMeters: Float
  maxZoom: Int
  removedFields: [String!]!
  notes: String
}

"""
Pointers to canonical metadata artifacts (STAC/DCAT/PROV), plus crosswalk identifiers.
"""
type CatalogRefs {
  stacCollectionId: String
  stacItemId: String
  dcatDatasetId: String
  provBundleId: String
  externalIds: [ExternalIdentifier!]!
  links: [Link!]!
}

# ------------------------------------------------------------------------------
# Service metadata
# ------------------------------------------------------------------------------

type ServiceInfo {
  name: String!
  description: String
  version: String!
  schemaVersion: String!
  buildTime: DateTime
  commit: String
  docsUrl: URL
  graphqlEndpoint: URL
  restOpenApiUrl: URL
  stacRootUrl: URL
  dcatFeedUrl: URL
  provRootUrl: URL
}

# ------------------------------------------------------------------------------
# Knowledge Graph model
# ------------------------------------------------------------------------------

"""
Base interface for entities stored in the Knowledge Graph (Neo4j).
"""
interface GraphEntity {
  id: ID!
  entityType: GraphEntityType!
  label: String!
  description: String
  aliases: [String!]!
  tags: [String!]!

  temporalExtent: TimeRange
  spatialExtent: SpatialExtent

  sensitivity: SensitivityLevel!
  redaction: RedactionPolicy

  catalogRefs: CatalogRefs

  createdAt: DateTime
  updatedAt: DateTime

  """
  Flexible relationship access for graph traversals.
  Use filters + pagination to avoid expensive queries.
  """
  relationships(
    first: Int = 20
    after: Cursor
    filter: GraphRelationshipFilterInput
  ): GraphEdgeConnection! @cost(weight: 5)
}

type GraphEdge implements Node {
  id: ID!
  type: String!
  from: GraphEntity!
  to: GraphEntity!
  properties: JSON
  createdAt: DateTime
}

type GraphEdgeEdge {
  cursor: Cursor!
  node: GraphEdge!
}

type GraphEdgeConnection {
  edges: [GraphEdgeEdge!]!
  pageInfo: PageInfo!
  totalCount: Int
}

type GraphEntityEdge {
  cursor: Cursor!
  node: GraphEntity!
}

type GraphEntityConnection {
  edges: [GraphEntityEdge!]!
  pageInfo: PageInfo!
  totalCount: Int
}

input GraphRelationshipFilterInput {
  types: [String!]
  direction: RelationshipDirection = BOTH
  """
  If false (default), resolvers must omit relationships that would leak sensitive details.
  """
  includeSensitive: Boolean = false
  since: DateTime
  until: DateTime
  targetEntityTypes: [GraphEntityType!]
}

input GraphTraversalInput {
  rootId: ID!
  relationshipTypes: [String!]
  direction: RelationshipDirection = BOTH
  depth: Int = 1
  limitNodes: Int = 500
  limitEdges: Int = 1000
  includeEntityTypes: [GraphEntityType!]
  includeSensitive: Boolean = false
}

type GraphTraversalResult {
  nodes: [GraphEntity!]!
  edges: [GraphEdge!]!
}

# ------------------------------------------------------------------------------
# Domain entities
# ------------------------------------------------------------------------------

type Person implements Node & GraphEntity {
  id: ID!
  entityType: GraphEntityType!
  label: String!
  description: String
  aliases: [String!]!
  tags: [String!]!
  temporalExtent: TimeRange
  spatialExtent: SpatialExtent
  sensitivity: SensitivityLevel!
  redaction: RedactionPolicy
  catalogRefs: CatalogRefs
  createdAt: DateTime
  updatedAt: DateTime
  relationships(first: Int = 20, after: Cursor, filter: GraphRelationshipFilterInput): GraphEdgeConnection!

  givenName: String
  familyName: String
  fullName: String
  birthDate: Date
  deathDate: Date
  occupations: [String!]!
  organizations(first: Int = 20, after: Cursor): OrganizationConnection!

  events(first: Int = 20, after: Cursor, filter: EventFilterInput): EventConnection!
  places(first: Int = 20, after: Cursor, filter: PlaceFilterInput): PlaceConnection!
  documents(first: Int = 20, after: Cursor, filter: DocumentFilterInput): DocumentConnection!
  datasets(first: Int = 20, after: Cursor, filter: DatasetFilterInput): DatasetConnection!
}

type Organization implements Node & GraphEntity {
  id: ID!
  entityType: GraphEntityType!
  label: String!
  description: String
  aliases: [String!]!
  tags: [String!]!
  temporalExtent: TimeRange
  spatialExtent: SpatialExtent
  sensitivity: SensitivityLevel!
  redaction: RedactionPolicy
  catalogRefs: CatalogRefs
  createdAt: DateTime
  updatedAt: DateTime
  relationships(first: Int = 20, after: Cursor, filter: GraphRelationshipFilterInput): GraphEdgeConnection!

  name: String!
  url: URL
  contact: ContactPoint
}

type Place implements Node & GraphEntity {
  id: ID!
  entityType: GraphEntityType!
  label: String!
  description: String
  aliases: [String!]!
  tags: [String!]!
  temporalExtent: TimeRange
  spatialExtent: SpatialExtent
  sensitivity: SensitivityLevel!
  redaction: RedactionPolicy
  catalogRefs: CatalogRefs
  createdAt: DateTime
  updatedAt: DateTime
  relationships(first: Int = 20, after: Cursor, filter: GraphRelationshipFilterInput): GraphEdgeConnection!

  placeType: String
  """
  Safe geometry for rendering (already generalized/redacted if needed).
  """
  displayGeometry: GeoJSON
  """
  Exact geometry may be restricted to privileged roles.
  """
  exactGeometry: GeoJSON @auth(requires: [REVIEWER, ADMIN]) @sensitive(level: SENSITIVE)

  parent: Place
  children(first: Int = 20, after: Cursor): PlaceConnection!

  events(first: Int = 20, after: Cursor, filter: EventFilterInput): EventConnection!
  datasets(first: Int = 20, after: Cursor, filter: DatasetFilterInput): DatasetConnection!
  documents(first: Int = 20, after: Cursor, filter: DocumentFilterInput): DocumentConnection!
}

type Event implements Node & GraphEntity {
  id: ID!
  entityType: GraphEntityType!
  label: String!
  description: String
  aliases: [String!]!
  tags: [String!]!
  temporalExtent: TimeRange
  spatialExtent: SpatialExtent
  sensitivity: SensitivityLevel!
  redaction: RedactionPolicy
  catalogRefs: CatalogRefs
  createdAt: DateTime
  updatedAt: DateTime
  relationships(first: Int = 20, after: Cursor, filter: GraphRelationshipFilterInput): GraphEdgeConnection!

  eventType: String
  start: DateTime
  end: DateTime

  participants(first: Int = 20, after: Cursor): PersonConnection!
  places(first: Int = 20, after: Cursor): PlaceConnection!
  documents(first: Int = 20, after: Cursor, filter: DocumentFilterInput): DocumentConnection!
  datasets(first: Int = 20, after: Cursor, filter: DatasetFilterInput): DatasetConnection!
}

type Document implements Node & GraphEntity {
  id: ID!
  entityType: GraphEntityType!
  label: String!
  description: String
  aliases: [String!]!
  tags: [String!]!
  temporalExtent: TimeRange
  spatialExtent: SpatialExtent
  sensitivity: SensitivityLevel!
  redaction: RedactionPolicy
  catalogRefs: CatalogRefs
  createdAt: DateTime
  updatedAt: DateTime
  relationships(first: Int = 20, after: Cursor, filter: GraphRelationshipFilterInput): GraphEdgeConnection!

  title: String!
  authors(first: Int = 20, after: Cursor): PersonConnection!
  publisher: Organization
  publishedAt: DateTime
  url: URL
  mimeType: String
  fileSizeBytes: Float
  """
  Short preview snippet (never the full document text).
  """
  excerpt(maxChars: Int = 500): String @cost(weight: 2)

  citedDatasets(first: Int = 20, after: Cursor): DatasetConnection!
  mentionedEntities(first: Int = 20, after: Cursor): GraphEntityConnection!
}

type Dataset implements Node & GraphEntity {
  id: ID!
  entityType: GraphEntityType!
  label: String!
  description: String
  aliases: [String!]!
  tags: [String!]!
  temporalExtent: TimeRange
  spatialExtent: SpatialExtent
  sensitivity: SensitivityLevel!
  redaction: RedactionPolicy
  catalogRefs: CatalogRefs
  createdAt: DateTime
  updatedAt: DateTime
  relationships(first: Int = 20, after: Cursor, filter: GraphRelationshipFilterInput): GraphEdgeConnection!

  title: String!
  kind: DatasetKind!
  keywords: [String!]!
  themes: [String!]!
  license: String
  attributions: [Attribution!]!
  contact: ContactPoint

  """
  Distribution endpoints (download URLs, tile services, etc.).
  """
  distributions: [Distribution!]!

  """
  Map layers that render this dataset in MapLibre/Cesium.
  """
  mapLayers(first: Int = 20, after: Cursor): MapLayerConnection!

  """
  Canonical catalog artifacts (STAC/DCAT/PROV) as typed objects + raw JSON.
  """
  stacCollection: StacCollection
  stacItems(first: Int = 20, after: Cursor, filter: StacItemFilterInput): StacItemConnection!
  dcat: DcatDataset
  prov: ProvBundle

  documents(first: Int = 20, after: Cursor, filter: DocumentFilterInput): DocumentConnection!
}

type Distribution {
  id: ID!
  title: String
  description: String
  format: String
  mediaType: String
  accessUrl: URL
  downloadUrl: URL
  checksum: String
  """
  For tiled datasets, provides a URL template like /tiles/{z}/{x}/{y}.pbf
  """
  tileUrlTemplate: String
  serviceType: String
  attributions: [Attribution!]!
}

type MapLayer implements Node {
  id: ID!
  dataset: Dataset
  name: String!
  description: String
  layerType: MapLayerType!
  sourceType: MapSourceType!
  minZoom: Int
  maxZoom: Int
  defaultVisible: Boolean!
  """
  MapLibre style layer/source fragments or other render configs.
  """
  style: JSON
  """
  Optional TileJSON or tileset URL (for vector/raster tiles).
  """
  url: URL
  """
  Time-aware layer config (for timeline slider).
  """
  timeConfig: TimelineLayerConfig
  attributions: [Attribution!]!
}

type TimelineLayerConfig {
  enabled: Boolean!
  timeField: String
  range: TimeRange
  step: Int
  stepUnit: TimeStepUnit
}

# ------------------------------------------------------------------------------
# Catalogs: STAC / DCAT / PROV (typed + raw JSON for completeness)
# ------------------------------------------------------------------------------

type StacExtent {
  spatial: JSON
  temporal: JSON
}

type StacProvider {
  name: String
  description: String
  roles: [String!]
  url: URL
}

type StacAsset {
  key: String!
  href: URL!
  title: String
  description: String
  type: String
  roles: [String!]
  extraFields: JSON
}

type StacCollection implements Node {
  id: ID!
  stacVersion: String
  stacExtensions: [String!]
  title: String
  description: String
  keywords: [String!]
  license: String
  providers: [StacProvider!]
  extent: StacExtent
  links: [Link!]!
  summaries: JSON
  raw: JSON!
}

type StacItem implements Node {
  id: ID!
  collectionId: String
  stacVersion: String
  stacExtensions: [String!]
  geometry: GeoJSON @sensitive(level: SENSITIVE)
  bbox: [Float!]
  datetime: DateTime
  properties: JSON!
  assets: [StacAsset!]!
  links: [Link!]!
  raw: JSON!
}

type DcatDistribution {
  id: ID!
  title: String
  description: String
  accessUrl: URL
  downloadUrl: URL
  mediaType: String
  format: String
  checksum: String
  raw: JSON
}

type DcatDataset implements Node {
  id: ID!
  title: String
  description: String
  keywords: [String!]
  themes: [String!]
  publisher: String
  contactPoint: ContactPoint
  license: String
  spatial: JSON
  temporal: JSON
  landingPage: URL
  distributions: [DcatDistribution!]!
  raw: JSON!
}

type ProvBundle implements Node {
  id: ID!
  generatedAtTime: DateTime
  """
  Raw PROV-O JSON-LD.
  """
  raw: JSON!
}

# ------------------------------------------------------------------------------
# Story engine (Story Nodes & narrative tours)
# ------------------------------------------------------------------------------

type MediaAsset implements Node {
  id: ID!
  url: URL!
  mimeType: String
  altText: String
  caption: String
  credit: Attribution
}

type MapViewConfig {
  mode3D: Boolean!
  center: Point
  zoom: Float
  bearing: Float
  pitch: Float
  bbox: BBox
  activeLayerIds: [ID!]!
  timeRange: TimeRange
}

type TimelineConfig {
  enabled: Boolean!
  range: TimeRange
  step: Int
  stepUnit: TimeStepUnit
}

type Story implements Node {
  id: ID!
  slug: String!
  title: String!
  summary: String
  status: StoryStatus!
  tags: [String!]!
  coverImage: MediaAsset
  nodes(first: Int = 50, after: Cursor): StoryNodeConnection!
  createdAt: DateTime
  updatedAt: DateTime
}

type StoryNode implements Node {
  id: ID!
  slug: String!
  title: String!
  summary: String
  status: StoryStatus!
  tags: [String!]!
  order: Int

  story: Story

  """
  Narrative content (Markdown is source of truth).
  """
  contentMarkdown: String!
  contentHtml: String

  """
  Evidence-first: citations must point to datasets/documents/items.
  """
  citations: [Citation!]!

  referencedEntities(first: Int = 50, after: Cursor): GraphEntityConnection!
  referencedDatasets(first: Int = 50, after: Cursor): DatasetConnection!

  mapView: MapViewConfig
  timeline: TimelineConfig
  media: [MediaAsset!]!

  createdAt: DateTime
  updatedAt: DateTime
}

type StoryEdge {
  cursor: Cursor!
  node: Story!
}

type StoryConnection {
  edges: [StoryEdge!]!
  pageInfo: PageInfo!
  totalCount: Int
}

type StoryNodeEdge {
  cursor: Cursor!
  node: StoryNode!
}

type StoryNodeConnection {
  edges: [StoryNodeEdge!]!
  pageInfo: PageInfo!
  totalCount: Int
}

# ------------------------------------------------------------------------------
# Focus Mode (evidence-backed AI assistant)
# ------------------------------------------------------------------------------

type SourceLocator {
  url: URL
  page: Int
  lineStart: Int
  lineEnd: Int
  timestamp: Float
  note: String
}

union Evidence = Dataset | Document | StacItem | StacCollection | ExternalSource

type ExternalSource implements Node {
  id: ID!
  title: String
  url: URL
  publisher: String
  publishedAt: DateTime
}

type Citation implements Node {
  id: ID!
  label: String
  evidence: Evidence
  locator: SourceLocator
  quote: String
  note: String
}

type FocusAnswer implements Node {
  id: ID!
  status: FocusAnswerStatus!
  question: String!
  """
  Always labeled as AI-generated if produced by the assistant.
  """
  aiGenerated: Boolean!
  confidence: Float
  answerMarkdown: String
  answerText: String

  """
  Must be evidence-linked; may be empty if status != ANSWERED.
  """
  citations: [Citation!]!

  usedEntities(first: Int = 50, after: Cursor): GraphEntityConnection!
  suggestedDatasets(first: Int = 20, after: Cursor): DatasetConnection!
  suggestedStoryNodes(first: Int = 20, after: Cursor): StoryNodeConnection!

  """
  Whether redaction/safety policies affected the output (e.g., generalized locations).
  """
  policyApplied: Boolean!
  warnings: [String!]!

  createdAt: DateTime
}

input MapContextInput {
  selectedEntityIds: [ID!]
  selectedDatasetIds: [ID!]
  selectedStoryNodeId: ID
  bbox: BBoxInput
  timeRange: TimeRangeInput
}

input FocusQueryInput {
  """
  Must be explicit user intent (opt-in) for AI generation.
  Server should reject if allowAi != true.
  """
  allowAi: Boolean!
  question: String!
  context: MapContextInput
}

# ------------------------------------------------------------------------------
# Collaboration (vNext) ‚Äî kept in-contract for roadmap alignment
# ------------------------------------------------------------------------------

type User implements Node {
  id: ID!
  username: String!
  displayName: String
  roles: [Role!]!
  createdAt: DateTime
}

type Comment implements Node {
  id: ID!
  author: User!
  target: Node!
  bodyMarkdown: String!
  bodyHtml: String
  createdAt: DateTime
  updatedAt: DateTime
  upvotes: Int!
  flags: Int!
}

type CommentEdge {
  cursor: Cursor!
  node: Comment!
}

type CommentConnection {
  edges: [CommentEdge!]!
  pageInfo: PageInfo!
  totalCount: Int
}

# ------------------------------------------------------------------------------
# Background jobs (pipelines, analyses, offline packs, etc.)
# ------------------------------------------------------------------------------

type Job implements Node {
  id: ID!
  kind: String!
  status: JobStatus!
  message: String
  progress: Float
  createdAt: DateTime
  startedAt: DateTime
  finishedAt: DateTime
  result: JSON
  error: String
}

# ------------------------------------------------------------------------------
# Analytics (for dashboard widgets; vNext but contract-defined)
# ------------------------------------------------------------------------------

type TimeseriesPoint {
  t: DateTime!
  v: Float
}

type TimeSeries implements Node {
  id: ID!
  label: String!
  unit: String
  points: [TimeseriesPoint!]!
  aggregation: TimeseriesAggregation!
  createdAt: DateTime
}

input TimeseriesQueryInput {
  datasetId: ID!
  """
  Region can be a Place id, or a GeoJSON polygon in `regionGeometry`.
  """
  placeId: ID
  regionGeometry: GeoJSON
  timeRange: TimeRangeInput
  metric: String!
  aggregation: TimeseriesAggregation = MEAN
  step: Int = 1
  stepUnit: TimeStepUnit = YEAR
}

# ------------------------------------------------------------------------------
# Federation (multi-matrix future; contract-first)
# ------------------------------------------------------------------------------

type MatrixInstance implements Node {
  id: ID!
  name: String!
  region: String
  baseUrl: URL!
  graphqlUrl: URL
  stacUrl: URL
  dcatUrl: URL
  provUrl: URL
}

type FederatedHit {
  instance: MatrixInstance!
  result: SearchResult!
}

type FederatedHitEdge {
  cursor: Cursor!
  node: FederatedHit!
}

type FederatedHitConnection {
  edges: [FederatedHitEdge!]!
  pageInfo: PageInfo!
  totalCount: Int
}

input FederatedSearchInput {
  mode: FederationMode = LOCAL_AND_REMOTE
  query: String!
  types: [SearchType!]
  first: Int = 20
  after: Cursor
}

# ------------------------------------------------------------------------------
# Filters, connections, and search
# ------------------------------------------------------------------------------

enum SearchType {
  PERSON
  PLACE
  EVENT
  DOCUMENT
  DATASET
  STORY
  STORY_NODE
  MAP_LAYER
}

union SearchResult = Person | Place | Event | Document | Dataset | Story | StoryNode | MapLayer

type SearchResultEdge {
  cursor: Cursor!
  node: SearchResult!
}

type SearchResultConnection {
  edges: [SearchResultEdge!]!
  pageInfo: PageInfo!
  totalCount: Int
}

input DatasetFilterInput {
  text: String
  kinds: [DatasetKind!]
  keywords: [String!]
  themes: [String!]
  license: String
  bbox: BBoxInput
  timeRange: TimeRangeInput
  sensitivity: [SensitivityLevel!]
}

enum DatasetSortField {
  TITLE
  CREATED_AT
  UPDATED_AT
}

input DatasetSortInput {
  field: DatasetSortField! = TITLE
  order: SortOrder! = ASC
}

type DatasetEdge {
  cursor: Cursor!
  node: Dataset!
}

type DatasetConnection {
  edges: [DatasetEdge!]!
  pageInfo: PageInfo!
  totalCount: Int
}

input DocumentFilterInput {
  text: String
  mimeTypes: [String!]
  publishedRange: TimeRangeInput
  sensitivity: [SensitivityLevel!]
}

type DocumentEdge {
  cursor: Cursor!
  node: Document!
}

type DocumentConnection {
  edges: [DocumentEdge!]!
  pageInfo: PageInfo!
  totalCount: Int
}

input EventFilterInput {
  text: String
  eventTypes: [String!]
  timeRange: TimeRangeInput
  bbox: BBoxInput
  sensitivity: [SensitivityLevel!]
}

type EventEdge {
  cursor: Cursor!
  node: Event!
}

type EventConnection {
  edges: [EventEdge!]!
  pageInfo: PageInfo!
  totalCount: Int
}

input PlaceFilterInput {
  text: String
  placeTypes: [String!]
  bbox: BBoxInput
  sensitivity: [SensitivityLevel!]
}

type PlaceEdge {
  cursor: Cursor!
  node: Place!
}

type PlaceConnection {
  edges: [PlaceEdge!]!
  pageInfo: PageInfo!
  totalCount: Int
}

input PersonFilterInput {
  text: String
  bornRange: TimeRangeInput
  diedRange: TimeRangeInput
  sensitivity: [SensitivityLevel!]
}

type PersonEdge {
  cursor: Cursor!
  node: Person!
}

type PersonConnection {
  edges: [PersonEdge!]!
  pageInfo: PageInfo!
  totalCount: Int
}

input OrganizationFilterInput {
  text: String
  sensitivity: [SensitivityLevel!]
}

type OrganizationEdge {
  cursor: Cursor!
  node: Organization!
}

type OrganizationConnection {
  edges: [OrganizationEdge!]!
  pageInfo: PageInfo!
  totalCount: Int
}

input MapLayerFilterInput {
  text: String
  layerTypes: [MapLayerType!]
  sourceTypes: [MapSourceType!]
  datasetIds: [ID!]
}

type MapLayerEdge {
  cursor: Cursor!
  node: MapLayer!
}

type MapLayerConnection {
  edges: [MapLayerEdge!]!
  pageInfo: PageInfo!
  totalCount: Int
}

input StoryFilterInput {
  text: String
  status: [StoryStatus!]
  tags: [String!]
}

input StoryNodeFilterInput {
  text: String
  status: [StoryStatus!]
  tags: [String!]
  referencedEntityIds: [ID!]
  referencedDatasetIds: [ID!]
}

input StacCollectionFilterInput {
  text: String
  license: String
  bbox: BBoxInput
  timeRange: TimeRangeInput
}

type StacCollectionEdge {
  cursor: Cursor!
  node: StacCollection!
}

type StacCollectionConnection {
  edges: [StacCollectionEdge!]!
  pageInfo: PageInfo!
  totalCount: Int
}

input StacItemFilterInput {
  text: String
  collectionId: String
  bbox: BBoxInput
  timeRange: TimeRangeInput
}

type StacItemEdge {
  cursor: Cursor!
  node: StacItem!
}

type StacItemConnection {
  edges: [StacItemEdge!]!
  pageInfo: PageInfo!
  totalCount: Int
}

# ------------------------------------------------------------------------------
# Query
# ------------------------------------------------------------------------------

type Query {
  serviceInfo: ServiceInfo!

  """
  Authenticated user (null if anonymous).
  """
  viewer: User

  """
  Generic node fetch (Relay).
  """
  node(id: ID!): Node
  nodes(ids: [ID!]!): [Node!]!

  """
  Knowledge Graph access.
  """
  graphEntity(id: ID!): GraphEntity
  graphEntities(first: Int = 20, after: Cursor, filter: GraphEntityFilterInput): GraphEntityConnection!
  graphTraversal(input: GraphTraversalInput!): GraphTraversalResult! @cost(weight: 10)

  """
  Typed convenience entrypoints.
  """
  person(id: ID!): Person
  people(first: Int = 20, after: Cursor, filter: PersonFilterInput): PersonConnection!

  place(id: ID!): Place
  places(first: Int = 20, after: Cursor, filter: PlaceFilterInput): PlaceConnection!

  event(id: ID!): Event
  events(first: Int = 20, after: Cursor, filter: EventFilterInput): EventConnection!

  document(id: ID!): Document
  documents(first: Int = 20, after: Cursor, filter: DocumentFilterInput): DocumentConnection!

  organization(id: ID!): Organization
  organizations(first: Int = 20, after: Cursor, filter: OrganizationFilterInput): OrganizationConnection!

  dataset(id: ID!): Dataset
  datasets(first: Int = 20, after: Cursor, filter: DatasetFilterInput, sort: DatasetSortInput): DatasetConnection!

  """
  Map layer catalog.
  """
  mapLayer(id: ID!): MapLayer
  mapLayers(first: Int = 20, after: Cursor, filter: MapLayerFilterInput): MapLayerConnection!

  """
  Story engine.
  """
  story(id: ID, slug: String): Story
  stories(first: Int = 20, after: Cursor, filter: StoryFilterInput): StoryConnection!

  storyNode(id: ID, slug: String): StoryNode
  storyNodes(first: Int = 20, after: Cursor, filter: StoryNodeFilterInput): StoryNodeConnection!

  """
  Catalog access (STAC/DCAT/PROV).
  """
  stacCollection(id: ID!): StacCollection
  stacCollections(first: Int = 20, after: Cursor, filter: StacCollectionFilterInput): StacCollectionConnection!

  stacItem(id: ID!): StacItem
  stacItems(first: Int = 20, after: Cursor, filter: StacItemFilterInput): StacItemConnection!

  dcatDataset(id: ID!): DcatDataset
  provBundle(id: ID!): ProvBundle

  """
  Unified search across graph + content.
  """
  search(query: String!, types: [SearchType!], first: Int = 20, after: Cursor): SearchResultConnection!

  """
  Focus Mode (opt-in AI) ‚Äî must cite evidence & respect sensitivity rules.
  """
  focusAnswer(input: FocusQueryInput!): FocusAnswer! @cost(weight: 20)

  """
  Collaboration (vNext).
  """
  comments(targetId: ID!, first: Int = 20, after: Cursor): CommentConnection! @auth(requires: [CONTRIBUTOR, REVIEWER, ADMIN])

  """
  Analytics widgets (vNext).
  """
  timeseries(input: TimeseriesQueryInput!): TimeSeries! @cost(weight: 10)

  """
  Federation (vNext).
  """
  matrixInstances(first: Int = 50, after: Cursor): [MatrixInstance!]!
  federatedSearch(input: FederatedSearchInput!): FederatedHitConnection! @cost(weight: 25)
}

input GraphEntityFilterInput {
  text: String
  types: [GraphEntityType!]
  tags: [String!]
  bbox: BBoxInput
  timeRange: TimeRangeInput
  sensitivity: [SensitivityLevel!]
}

# ------------------------------------------------------------------------------
# Mutations
# ------------------------------------------------------------------------------

input DatasetContributionInput {
  title: String!
  description: String
  kind: DatasetKind = OTHER
  license: String
  keywords: [String!]
  themes: [String!]
  sourceUrls: [URL!]
  notes: String
}

type DatasetContribution implements Node {
  id: ID!
  submittedBy: User!
  submittedAt: DateTime!
  status: String!
  notes: String
  job: Job
}

input CreateCommentInput {
  targetId: ID!
  bodyMarkdown: String!
}

type Mutation {
  """
  Submit a dataset contribution (crowdsourcing / partner contributions).
  Processing & validation happen asynchronously.
  """
  submitDatasetContribution(input: DatasetContributionInput!): DatasetContribution! @auth(requires: [CONTRIBUTOR])

  """
  Story authoring is typically GitOps; mutation is optional for future editor flows.
  """
  # upsertStoryNode(...): StoryNode @auth(requires: [REVIEWER, ADMIN])

  """
  Create a comment (vNext).
  """
  createComment(input: CreateCommentInput!): Comment! @auth(requires: [CONTRIBUTOR, REVIEWER, ADMIN])

  """
  Generic job trigger (pipelines, offline packs, analyses).
  """
  runJob(kind: String!, payload: JSON): Job! @auth(requires: [REVIEWER, ADMIN])
}
```
